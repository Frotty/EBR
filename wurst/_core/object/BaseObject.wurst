package BaseObject
import public Entity
import public TerrainUtils
import public ConfigValue
import public SetupObject
import public SerializeIds
import Assets

/*  ---Creating a new Baseobject---
	Creating the baseobject will need 3 parameters
	the unit u: in whichs Userdata the struct is saved
	the radius: The Range of the InrangeDetection
	the code c: name of the static method that is being called upon inRangeEvent
*/

public code CODE_NULL = null
public constant KEY_RALLY_X = "r"
public constant KEY_RALLY_Y = "s"

public class StaticBaseObject extends UnitEntity
	private vec3 rallyPoint
	private unit rallyUnit = null
	private angle rallyAngle = angle(0)
	effect noRally

	protected trigger inRangeTrig // Trigger for inRange detection

	construct( vec2 pos, unit u, real radius, code action, code cond )
		super(u)
		this.setCurrentRegion()
		noRally = addEffect(Other.questionmark, pos)
		actor..addAbility(GHOST_VIS_ID)
		..addAbility(REMOVE_ID)
		this.setCurrentRegion()
		rallyPoint = this.pos

		if radius > 0. // a few Objects like Spinner dont have inRange Events, we dont want to create unused triggers
			inRangeTrig = CreateTrigger()
			inRangeTrig.registerUnitInRangeSource( actor, radius )
			if cond == null
				inRangeTrig.addCondition(Condition((function isProper)))
			else
				inRangeTrig.addCondition(Condition(cond))
			inRangeTrig.addAction(action)
		EventListener.add(actor, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER, () -> adjustRallypoint())
		EventListener.add(actor, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER, () -> adjustRallypoint())

	function clearQuestionmark()
		if noRally != null
			noRally.destr()
			noRally = null

	static function isProper() returns boolean
		return GetTriggerUnit().getFlyHeight() < 22

	static function adjustRallypoint() //method that automaticly adjusts the RallyXY of the baseobject
		let u			= GetOrderedUnit()
		let target		= GetOrderTargetUnit()
		let itm			= GetOrderTargetItem()
		let targetPoint = vec2(GetOrderPointX(), GetOrderPointY())
		let orderid		= GetIssuedOrderId()
		
		let obj  = u.getEntity() castTo StaticBaseObject

		if orderid == 0xD000C or orderid == 851971
			if target == null
				if itm == null
					obj.setRallyPoint(targetPoint)
				else
					obj.rallyPoint = itm.getPos().toVec3()
			else
				let data = target.getEntity()
				if data != null and data instanceof SetupObject
					obj.rallyUnit = (data castTo SetupObject).actor
				else
					obj.rallyUnit = target
				obj.rallyPoint = obj.rallyUnit.getPos().toVec3()
			if obj.noRally != null
				obj.noRally.destr()
				obj.noRally = null
					
	function setRallyPoint(vec2 tpos)
		rallyPoint = tpos.toVec3()
		rallyUnit = null
		rallyAngle = pos.angleTo2d(rallyPoint)
		clearQuestionmark()

	function getRallyPoint() returns vec3
		if rallyUnit == null or not rallyUnit.isAliveTrick()
			return rallyPoint
		else
			if rallyUnit.getOwner() != DUMMY_PLAYER
				return rallyUnit.getPos3with(0)
			else
				return pos

	function getRallyUnit() returns unit
		return rallyUnit

	function getRallyAngle() returns angle
		if rallyUnit != null
			rallyAngle = pos.angleTo2d(rallyUnit.getPos())
		return rallyAngle

	ondestroy
		actor.clearRegister()
		inRangeTrig.destr()
		clearQuestionmark()

	override function serialize() returns Json
		let json = super.serialize()
		if rallyUnit != null
			rallyPoint = rallyUnit.getPos3Zero()

		json
		..addProperty(new Property(KEY_RALLY_X, (rallyPoint.x-serializeOrigin.x).toInt().toString()))
		..addProperty(new Property(KEY_RALLY_Y, (rallyPoint.y-serializeOrigin.y).toInt().toString()))
		return json

	override function deserialize(Json json)
		super.deserialize(json)
		let rpos = vec2(serializeOrigin.x+json.getReal(KEY_RALLY_X), serializeOrigin.y+json.getReal(KEY_RALLY_Y))
		setRallyPoint(rpos)
