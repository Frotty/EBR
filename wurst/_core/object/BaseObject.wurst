package BaseObject
import public Entity
import public TerrainUtils
import public ConfigValue
import public SetupObject
import public SerializeIds
import public ChannelAbilityPreset
import Assets

/*  ---Creating a new Baseobject---
	Creating the baseobject will need 3 parameters
	the unit u: in whichs Userdata the struct is saved
	the radius: The Range of the InrangeDetection
	the code c: name of the static method that is being called upon inRangeEvent

	A Baseobject is usually a circle. A unit that doesn't move and has an onRange trigger.
*/
public code CODE_NULL = null
public constant KEY_RALLY_X = "r"
public constant KEY_RALLY_Y = "s"


public class StaticBaseObject extends UnitEntity
	private vec3 rallyPoint
	private unit rallyUnit = null
	private angle rallyAngle = angle(0)
	effect noRally
	effect disFx = null
	boolean enabled = true

	protected trigger inRangeTrig // Trigger for inRange detection

	construct(vec2 pos, unit u, real radius, code action, code cond )
		super(u)
		this.setCurrentRegion()
		noRally = addEffect(Objects.questionMark1, pos)
		actor..addAbility(GHOST_VIS_ID)
		..addAbility(REMOVE_OBJECT_ID)
		this.setCurrentRegion()
		rallyPoint = this.pos

		if radius > 0. // a few Objects like Spinner dont have inRange Events, we dont want to create unused triggers
			inRangeTrig = CreateTrigger()
			inRangeTrig.registerUnitInRangeSource( actor, radius )
			if cond == null
				inRangeTrig.addCondition(Condition((function isProper)))
			else
				inRangeTrig.addCondition(Condition(cond))
			inRangeTrig.addAction(action)
		EventListener.add(actor, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER, () -> adjustRallypoint())
		EventListener.add(actor, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER, () -> adjustRallypoint())
		EventListener.add(actor, EVENT_PLAYER_UNIT_SPELL_CAST, () -> onCast())

	function setEnabled(boolean flag)
		if flag and not enabled
			enabled = true
			activate()
			actor..removeAbility(TURN_ON_ID)..addAbility(TURN_OFF_ID)
			flashEffect(Abilities.ancestralSpiritCaster, pos)
			if disFx != null
				disFx.destr()
		else if enabled
			enabled = false
			deactivate()
			actor..removeAbility(TURN_OFF_ID)..addAbility(TURN_ON_ID)
			if disFx != null
				disFx.destr()

			var path = ""
			if GetLocalPlayer() == owner
				path = Abilities.sleepTarget
			disFx = addEffect(path, pos)

	function onCast()
		let id = GetSpellAbilityId()
		switch id
			case TURN_ON_ID
				setEnabled(true)
			case TURN_OFF_ID
				setEnabled(false)

	function clearQuestionmark()
		if noRally != null
			noRally.destr()
			noRally = null

	function addQuestionmark()
		if noRally == null
			noRally = addEffect(Objects.questionMark1, pos)

	function isActive() returns boolean
		return active

	static function isProper() returns boolean
		return GetTriggerUnit().getFlyHeight() < 22 and (GetTriggeringTrigger().getSource().getUserData() castTo thistype).enabled

	static function adjustRallypoint() //method that automaticly adjusts the RallyXY of the baseobject
		let u			= GetOrderedUnit()
		let target		= GetOrderTarget()
		let utarget 	= GetOrderTargetUnit()
		let itm			= GetOrderTargetItem()
		let targetPoint = vec2(GetOrderPointX(), GetOrderPointY())
		let orderid		= GetIssuedOrderId()
		
		let obj  = u.getEntity() castTo StaticBaseObject

		if orderid == 0xD000C or orderid == 851971
			if target == null
				if itm == null
					obj.setRallyPoint(targetPoint)
				else
					obj.setRallyPoint(itm.getPos())
			else
				if utarget != null
					let data = utarget.getEntity()
					if data != null and data instanceof SetupObject
						obj.rallyUnit = (data castTo SetupObject).actor
					else
						obj.rallyUnit = utarget
					obj.clearQuestionmark()
				obj.rallyPoint = target.getPos().toVec3()
			if obj.noRally != null
				obj.noRally.destr()
				obj.noRally = null
					
	function setRallyPoint(vec2 tpos)
		rallyPoint = tpos.toVec3()
		rallyUnit = null
		rallyAngle = pos.angleTo2d(rallyPoint)
		clearQuestionmark()

	function getRallyPoint() returns vec3
		if rallyUnit == null or not rallyUnit.isAliveTrick()
			return rallyPoint
		else
			if rallyUnit.getOwner() != DUMMY_PLAYER
				return rallyUnit.getPos3with(0)
			else
				return pos

	function getRallyUnit() returns unit
		return rallyUnit

	function getRallyAngle() returns angle
		if rallyUnit != null
			rallyAngle = pos.angleTo2d(rallyUnit.getPos())
		return rallyAngle

	ondestroy
		actor.clearRegister()
		inRangeTrig.destr()
		clearQuestionmark()
		if disFx != null
			disFx.destr()
			disFx = null

	override function serialize() returns Json
		let json = super.serialize()
		if rallyUnit != null
			rallyPoint = rallyUnit.getPos3Zero()

		json
		..addProperty(new Property(KEY_RALLY_X, (rallyPoint.x-serializeOrigin.x).toInt().toString()))
		..addProperty(new Property(KEY_RALLY_Y, (rallyPoint.y-serializeOrigin.y).toInt().toString()))
		return json

	override function deserialize(Json json)
		super.deserialize(json)
		let rpos = vec2(serializeOrigin.x+json.getReal(KEY_RALLY_X), serializeOrigin.y+json.getReal(KEY_RALLY_Y))
		setRallyPoint(rpos)
