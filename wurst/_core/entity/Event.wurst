package Event
import public EventHelper
import LinkedList
import RegisterEvents
import HashMap
import ErrorHandling
import OnUnitEnterLeave

constant MAX_EVENTS = 50

public abstract class EventListener
	static HashMap<int, LinkedList<EventListener>> listenerMap = new HashMap<int, LinkedList<EventListener>>()
	static HashMap<unit, int> unitListenerMap = new HashMap<unit, int>()
	
	static function add(eventid eventId, EventListener listener)
		let id = eventId.toIntId()
		if not listenerMap.has(id)
			listenerMap.put(id, new LinkedList<EventListener>())
			
		listenerMap.get(id).add(listener)
		
	static function add(unit u, eventid eventId, EventListener listener)
		let id = eventId.toIntId()
		LinkedList<EventListener> list = null
		if not unitListenerMap.has(u)
			list = new LinkedList<EventListener>()
			let startId = 1 + MAX_EVENTS + (list castTo int) * MAX_EVENTS
			unitListenerMap.put(u, startId)
			
		let listenerId = unitListenerMap.get(u) + id
		if not listenerMap.has(listenerId)
			if list == null
				list = new LinkedList<EventListener>()
			listenerMap.put(listenerId, list)
		
		listenerMap.get(listenerId).add(listener)
		
	static function addSpellEffect(unit u, int abilId, EventListener listener)
		add(u, EVENT_UNIT_SPELL_EFFECT, () -> begin
			if GetSpellAbilityId() == abilId
				listener.onEvent()
		end)
		
	static function generalEventCallback()
		let id = GetTriggerEventId().toIntId()
		let trigUnit = GetTriggerUnit()
		if listenerMap.has(id)
			for listener in listenerMap.get(id)
				listener.onEvent()
		if unitListenerMap.has(trigUnit)
			let list = listenerMap.get(unitListenerMap.get(trigUnit) + id)
			if list != null
				for listener in list
					listener.onEvent()		
			
	abstract function onEvent()
			
	
trigger unitTrig = CreateTrigger()

public function eventid.toIntId() returns int
	var id = eventidToIndex[this.getHandleId()]
	if id == 0
		id = registerEventId(this)
	return id
			
int array eventidToIndex
int eventTypeCounter = 0

function registerEventId(eventid evnt) returns int
	eventTypeCounter++
	eventidToIndex[evnt.getHandleId()] = eventTypeCounter
	if eventTypeCounter > MAX_EVENTS
		error("too many event types, increase MAX_EVENTS constant")
	return eventTypeCounter
	
function registerEventsForUnit(unit u)
	unitTrig.registerUnitEvent(u, EVENT_UNIT_DAMAGED)

function unregisterEventsForUnit(unit u)
	if EventListener.unitListenerMap.has(u)
		for int i = 0 to eventTypeCounter-1
			let id = EventListener.unitListenerMap.get(u)
			let list = EventListener.listenerMap.get(id)
			if list != null
				for listener in list
					destroy listener
				destroy list
				EventListener.listenerMap.remove(id)

init
	// Register Events when unit enters map
	onEnter(() -> registerEventsForUnit(getEnterLeaveUnit()))
	// Delete 
	onLeave(() -> unregisterEventsForUnit(getEnterLeaveUnit()))
	
	// Register Actions
	unitTrig.addAction(function EventListener.generalEventCallback)		
	
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_CONSTRUCT_START, function EventListener.generalEventCallback)
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_USE_ITEM, function EventListener.generalEventCallback)
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_UPGRADE_FINISH, function EventListener.generalEventCallback)
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_EFFECT, function EventListener.generalEventCallback)
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_PICKUP_ITEM, function EventListener.generalEventCallback)
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_SPELL_CAST, function EventListener.generalEventCallback)
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DEATH, function EventListener.generalEventCallback)
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER, function EventListener.generalEventCallback)
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER, function EventListener.generalEventCallback)
	registerPlayerUnitEvent(EVENT_PLAYER_UNIT_DROP_ITEM, function EventListener.generalEventCallback)
	
