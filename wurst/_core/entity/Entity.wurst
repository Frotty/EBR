package Entity
import public LinkedListModule
import public Serializable
import public TerrainUtils
import public Fx
import public TimerUtils
import public HashMap
import public LinkedList
import public Event
import public Basics
import public GameConstants
import ErrorHandling
import public initlater RegionData

public abstract class SensorListener
	abstract function onSensor(UnitEntity source, UnitEntity target)
	
public module Sensor
	private trigger inRangeTrig = null
	private unit actor = null
	private static HashMap<trigger, SensorListener> sensorListeners = new HashMap<trigger, SensorListener>()

	function addSensorListener(UnitEntity e, SensorListener listener)
		if listener == null
			error("Trying to add null listener")
		inRangeTrig = CreateTrigger()
		inRangeTrig.registerUnitInRangeSource(e.actor, e.radius, null)
		this.actor = e.actor
		sensorListeners.put(inRangeTrig, listener)
		inRangeTrig.addAction( () -> begin
			let trig = GetTriggeringTrigger()
			let u = GetTriggerUnit()
			if u.getUserData() > 0
				let target = u.getEntity() castTo UnitEntity
				if target != null and not target.done
					let slistener = sensorListeners.get(trig)
					if slistener != null
						slistener.onSensor(trig.getSource().getEntity() castTo UnitEntity, target)
		end)
		
	ondestroy
		if inRangeTrig != null
			destroy sensorListeners.get(inRangeTrig)
			sensorListeners.remove(inRangeTrig)
			actor.clearRegister()


public function unit.abortOrder() returns boolean
	if IsUnitPaused(this)
		return false
	else
		PauseUnit(this, true)
		IssueImmediateOrder(this, "stop")
		PauseUnit(this, false)
	return true

public function unit.getEntity() returns Entity
	return this.getUserData() castTo Entity
	
public function item.getEntity() returns Entity
	return this.getUserData() castTo Entity
	
public function unit.setEntity(Entity e)
	this.setUserData(e castTo int)

/** Base Entity Class  */
public abstract class Entity implements Serializable
	RegionData currentRegion
	use LinkedListModule
	
	/** 3d vector position */
	vec3 pos
	/** 3d vector velocity */
	vec3 vel
	
	/** radius */
	real radius = 0.
	/** speed factor (multiplies to added velocity) */
	real speedFactor = 1.
	
	/** owning player */
	player owner
	
	/** flag for being static */
	boolean isStatic 	= false
	/** sleeping or active? */
	boolean active 		= true
	/** for removing */
	boolean done 		= false

	construct( vec3 pos, player owner )
		setup(pos, vec3(0,0,0), 0, owner)

	construct( vec3 pos, real radius, player owner )
		setup(pos, vec3(0,0,0), radius, owner)
		
	construct( vec3 pos, vec3 vel, player owner )
		setup(pos, vel, 0, owner)
		
	construct( vec3 pos, vec3 vel, real radius, player owner )
		setup(pos, vel, radius, owner)

	function setup(vec3 pos, vec3 vel, real radius, player owner)
		this.pos = pos
		this.vel = vel
		this.owner = owner
		this.radius = radius
		this.currentRegion = getRegionData(pos)
		
	function setPos(vec3 tpos)
		this.pos = tpos
		
	function addPos(vec3 pos)
		this.pos += pos

	function getPos() returns vec3
		return pos
		
	function setVel( vec3 vel )
		this.vel = vel
		active = true
	
	function addVel( vec3 vel )
		this.vel += vel
		active = true

	function getVel() returns vec3
		return vel
		
	function setTarget( vec3 tpos, real speed )
		var t = pos.distanceTo2d(tpos) / speed
		let tangle = pos.angleTo2d(tpos)
		let e = getTerrainZ(tpos.x,tpos.y)
		
		if t < 1.
			t = 1./speed
		
		let startZVelocity = ((-currentRegion.gravity.z * t) / 2 - pos.z/t + e/t)
		this.setVel(vec3( Cos(tangle.radians()) * speed, Sin(tangle.radians()) * speed, startZVelocity))

	function terminate()
		done = true
		
	/** This function is called every ANIMATION_PERIOD tick if the Entity is active */
	abstract function update()
	
	override function serialize() returns string
		return pos.toString()
		
	override function deserialize(string scode) returns Serializable
		return null
	
abstract public class UnitEntity extends Entity
	unit actor
	
	construct( vec3 pos, unit actor )
		super(pos, actor.getOwner())
		this.actor = actor
		actor..setEntity(this)..addAbility(HEIGHT_ENABLER)..removeAbility(HEIGHT_ENABLER)
		
	construct( vec3 pos, real radius, unit actor )
		super(pos, radius, actor.getOwner())
		this.actor = actor
		actor..setEntity(this)..addAbility(HEIGHT_ENABLER)..removeAbility(HEIGHT_ENABLER)
		
	override function update()
		updatePos()
		
	function updatePos()
		pos = vec3(actor.getX(), actor.getY(), pos.z)
		
	function setNewActor(unit u)
		actor.remove()
		actor = u
		actor.setEntity(this)
		
	override function setPos(vec3 tpos)
		pos = tpos
		SetUnitPosition(actor, tpos.x,tpos.y)
		actor.setFlyHeight(tpos.z - getTerrainZ(tpos.x, tpos.y), 0)
		
	function setXY(vec3 tpos)
		pos = tpos
		actor.setXY(tpos)
		actor.setFlyHeight(tpos.z - getTerrainZ(tpos.x, tpos.y), 0)

	override function getPos() returns vec3
		updatePos()
		return pos

abstract public class FxEntity extends Entity
	protected Fx fx
	boolean silent = false
	
	construct( vec3 pos, real radius, player owner, angle xyAngle, string sfxpath )
		super(pos, radius, owner)
		fx = new Fx(pos, xyAngle, sfxpath)
		fx.setOwner(owner, true)
		
	construct( vec3 pos, real radius, player owner, angle xyAngle )
		super(pos, radius, owner)
		fx = new Fx(pos, xyAngle)
		fx.setOwner(owner, true)
	
	construct( vec3 pos, player owner, angle xyAngle )
		super(pos, 0., owner)
		fx = new Fx(pos, xyAngle)
		fx.setOwner(owner, true)
		
	override function update()
		pos += (vel*speedFactor)
		fixPos()

	function setFx(string sfxpath)
		fx.setFx(sfxpath)
		
	function fixPos()
		fx.setXYZ(pos)
		
	function getDummy() returns unit
		return fx.getDummy()
		
	override function setPos(vec3 tpos)
		pos = tpos
		fx.setPos(tpos.x,tpos.y)
		
	ondestroy
		if silent
			fx.hiddenDestroy()
		else
			destroy fx
