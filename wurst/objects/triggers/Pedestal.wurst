package Pedestal
import initlater InstantBuild
import public PedestalObjects
import Assets
import BaseObject
import ClosureForGroups
import HashMap
import PlayerData
import FileIO
import Builder
import SyncWrapper
import CodeManager
import JsonParser
import TerrainBlocker
import TileData
import LZW
import StringUtils
import ItemObject

constant CHAR_STEPSIZE = 180

public class MemoryAccessPedestal extends StaticBaseObject
	static constant ENTITIES_KEY = "e"
	static constant TILES_KEY = "t"

	static MemoryAccessPedestal array lastRef 
	private LinkedList<Serializable> entities = new LinkedList<Serializable>()
	private LinkedList<TileData> tiles = new LinkedList<TileData>()
	private HashMap<Serializable, effect> effects = new HashMap<Serializable, effect>()
	private boolean syncingDone = true
	private FText ttag = createFText(pos, "", 12)
	let bs = new BigString()
	let parser = new JsonParser()
	let listparser = new JsonParser()
	
	construct(vec2 pos, player owner)
		super(pos, createUnit(owner, PED_ID, pos, angle(bj_UNIT_FACING)), 0, CODE_NULL, CODE_NULL)
		setPos(pos.toTile().toVec3())
		ttag.tt.center(pos.toVec3(), "|cff4AA542ready", 10)
		actor..addAbility(SAVE1_ID)..addAbility(LOAD1_ID)..addAbility(SAVE2_ID)..addAbility(SAVE3_ID)
		..addAbility(SELECT_TILE_ID)..addAbility(LOAD2_ID)..addAbility(SELECT_AOE_TILE_ID)
		..addAbility(LOAD3_ID)..addAbility(REMOVE_ID)..addAbility(SELECT_SINGLE_ID)..addAbility(SELECT_AOE_ID)
		clearQuestionmark()
		
	function addObj(Entity serializable, boolean removeIfExists)
		if serializable instanceof Escaper or serializable instanceof Builder or serializable instanceof MemoryAccessPedestal
			return
		if getRegionData(serializable.getPos()).canBuild(owner)
			let itr = entities.staticItr()
			for entity from itr
				if entity == serializable
					if removeIfExists
						destroy itr.remove()
					return
			// Isnt added yet
			entities.add(serializable)
			flashEffect(Other.healtarget, serializable.getPos())
			if serializable instanceof ItemObject
				let io = serializable castTo ItemObject
				effects.put(serializable, io.setup.addEffect(Other.innerfiretarget, "overhead"))
			else if serializable instanceof StaticSetupObject
				let so = serializable castTo StaticSetupObject
				effects.put(serializable, so.setup.addEffect(Other.innerfiretarget, "overhead"))
			else if serializable instanceof UnitEntity
				let ue = serializable castTo UnitEntity
				effects.put(serializable, ue.actor.addEffect(Other.innerfiretarget, "overhead"))

	function addTile(vec2 tpos, boolean removeIfExists)
		let targPos = tpos.toTile()
		if getRegionData(targPos).canBuild(owner)
			let mpos = matrixpos((targPos.x / 128.).toInt(), (targPos.y / 128.).toInt())
			let itr = tiles.staticItr()
			for tile from itr
				if tile.offset == mpos
					if removeIfExists
						destroy itr.remove()
					return

			if getTileFromType(targPos) != Tile.UNWALKABLE
				tiles.add(new TileData(targPos, mpos, owner))

	function loadSlot(int slotId)
		nullTimer(() -> begin
			actor.pause()
			ttag.tt..center(pos, "|cff0884CEloading...", 10)
			lastRef[owner.getId()] = this
			getSyncedFile(pData[owner.getId()], "dataSlot" + slotId.toString() + ".pld", Filter(() -> onLoadSlotSynced()))
		end)

	static function onLoadSlotSynced()
		printLog(Loglevel.DEBUG, "synced")
		let pd = pData[getSyncedData().p.getId()]
		let ref = lastRef[pd.id]
		ref.ttag.tt..center(ref.pos, "|cff0884CEdecompressing...", 10)
		ref.syncingDone = true
		if pd.syncPayload.syncedFile.size <= 0
			destroy pd.syncPayload
			pd.syncPayload = null
			return
		var compressedString = new BigString()
		var buildString = pd.syncPayload.syncedFile.read()
		while buildString != null
			compressedString.addString(buildString)
			buildString = pd.syncPayload.syncedFile.read()
		printLog(Loglevel.DEBUG, "Reconstructed")
		compressedString.debugPrint()
		serializeOrigin = ref.pos.toVec2().toTile().toVec3()
		destroy pd.syncPayload
		pd.syncPayload = null
		decompress(compressedString, (PayloadCallback cb1) -> begin
			printLog(Loglevel.DEBUG, "on finish decompress")
			ref.parser.setInput(cb1.customData castTo BigString)
			ref.parser.parse((PayloadCallback cb2) -> begin
				printLog(Loglevel.DEBUG, "on finish parse")
				ref.parser.output.getStringList(ENTITIES_KEY, ref.listparser, (PayloadCallback cb3) -> begin
					ref.loadEntities(ref.listparser.outputList)
				end)
			end)
		end)

	
	LLStaticIterator<BigSubString> itr

	function loadEntities(LinkedList<BigSubString> list)
		// load entities
		ttag.tt..center(pos, "|cff0884CEloading Entities...", 10)
		itr = list.staticItr()
		PayloadCallback pcb = (PayloadCallback cb) -> begin
			if itr.hasNext()
				bs.reset()
				let next = itr.next()
				next.next = null
				listparser.setInput(bs..addSubString(next))
				listparser.parse((PayloadCallback cb2) -> begin
					let json = listparser.output
					let npos = vec2(json.getReal(KEY_X), json.getReal(KEY_Y))
					let tId = json.getInt(KEY_TYPE)
					let obj = newObjectFromId(owner, serializeOrigin.toVec2() + npos, tId)
					if obj != null
						obj.deserialize(listparser.output)
					else
						print("invalid data")
					listparser.output.reset()
					cb.doStep()
				end)
			else
				ttag.tt..center(pos, "|cff0884CEEntites loaded!", 10)
				printLog(Loglevel.DEBUG, "entities loaded")
				doAfter(0.5, () -> begin
					parser.output.getStringList(TILES_KEY, listparser, (PayloadCallback cb) -> begin
						printLog(Loglevel.DEBUG, "load tiles1")
						loadTiles((cb.customData castTo JsonParser).outputList)
					end)
				end)
				
		end
		pcb.doStep()

	function loadTiles(LinkedList<BigSubString> list)
		printLog(Loglevel.DEBUG, "load tiles2")
		ttag.tt..center(pos, "|cff0884CEloading Tiles...", 10)
		let td = new TileData()
		let bs = new BigString()
		td.owner = owner
		var itr = list.staticItr()
		PayloadCallback pcb = (PayloadCallback cb1) -> begin
			var continue = true
			printLog(Loglevel.DEBUG, "doSeq loadTiles")
			if itr.hasNext()
				bs.reset()
				let next = itr.next()
				next.next = null
				printLog(Loglevel.DEBUG, "doSeq loadTiles1: " + next.getCombined())
				parser.setInput(bs..addSubString(next))
				parser.parse((PayloadCallback cb2) -> begin
					printLog(Loglevel.DEBUG, "doSeq loadTile2s")
					td..deserialize(parser.output)
					parser.output.reset()
					cb1.doStep()
				end)
			else
				continue = false
				printLog(Loglevel.DEBUG, "load finished")
				ttag.tt..center(pos, "|cffFFBD21load finished!", 10)
				destroy td
				actor.unpause()
			return continue
		end
		pcb.doStep()


	BigString tileString = new BigString()
	BigString entString = new BigString()

	int currentSlotId
	function saveSlot(int slotId)
		actor.pause()
		ttag.tt..center(pos, "|cff0884CEsaving...", 10)
		serializeOrigin = pos.toVec2().toTile().toVec3()
		let itr = entities.staticItr()
		currentSlotId = slotId
		entString.reset()
		entString.addString(JSON_OPEN_ARRAY.token)
		doSeq((SeqCallback cb) -> begin
			var continue = true
			if itr.hasNext()
				let next = itr.next()
				let json = next.serialize()
				json.addToBigString(entString)
				destroy json
				if itr.hasNext()
					entString.addString(JSON_SIGN_COMMA.token)

				effects.get(next).destr()
				effects.remove(next)
				itr.remove()
			else
				continue = false
				entString.addString(JSON_CLOSE_ARRAY.token)
				saveTileSeq()
			return continue
		end)

	function saveTileSeq()
		ttag.tt..center(pos, "|cff0884CEsaving tiles...", 10)
		tileString.reset()
		tileString.addString(JSON_OPEN_ARRAY.token)
		let itr = tiles.staticItr()
		doSeq((SeqCallback cb) -> begin
			var continue = true
			if itr.hasNext()
				itr.next().serialize().addToBigString(tileString)
				if itr.hasNext()
					tileString.addString(JSON_SIGN_COMMA.token)
				destroy itr.remove()
			else
				continue = false
				tileString.addString(JSON_CLOSE_ARRAY.token)
				tileString.debugPrint()
				saveFile()
			return continue
		end)

	function saveFile()
		ttag.tt..center(pos, "|cff0884CEcompressing...", 10)
		let json = new Json()
		let big = new BigString()
		json.addProperty(new Property(new BigSubString(ENTITIES_KEY), entString.asSubstring()))
		json.addProperty(new Property(new BigSubString(TILES_KEY), tileString.asSubstring()))
		
		json.addToBigString(big)
		destroy json
		printLog(Loglevel.DEBUG, "start compress")
		compress(big, (PayloadCallback cb) -> begin
			let compressedData = cb.customData castTo BigString
			if GetLocalPlayer() == owner
				let f = File.open("dataSlot" + currentSlotId.toString() + ".pld", Mode.WRITE)
				while compressedData.getLength() > BIG_SUBSTRING_LEN
					f.write(compressedData.getString(0, BIG_SUBSTRING_LEN))
					compressedData.startoffset += BIG_SUBSTRING_LEN
				f.write(compressedData.getString(0))
				f.close()
			ttag.tt..center(pos, "|cffFFBD21save finished!", 10)
			destroy big
			actor.unpause()
		end)
		
		

	override function onCast()
		super.onCast()
		let id = GetSpellAbilityId()
		let tpos = getSpellTargetPos()
		switch id
			case SELECT_AOE_ID
				forUnitsInRange(tpos, AOE_PICK_RANGE, (unit u) -> begin
					if u != actor
						if u.getEntity() != null
							var ed = u.getEntity()
							if ed.owner == owner
								addObj(ed, false)
				end)
			case SELECT_SINGLE_ID
				if GetSpellTargetUnit().getEntity().owner == owner
					addObj(GetSpellTargetUnit().getEntity(), true)
			case SELECT_TILE_ID
				addTile(tpos, true)
			case SAVE1_ID
				saveSlot(1)
			case SAVE2_ID
				saveSlot(2)
			case SAVE3_ID
				saveSlot(3)
			case SAVE4_ID
				saveSlot(4)
			case LOAD1_ID
				loadSlot(1)
			case LOAD2_ID
				loadSlot(2)
			case LOAD3_ID
				loadSlot(3)
			case LOAD4_ID
				loadSlot(4)
			case SELECT_AOE_TILE_ID
				let val = (AOE_PICK_RANGE/128.).round()
				for x = -val to val
					for y = -val to val
						addTile((tpos+vec2(x*128.,y*128.)), false)

	ondestroy
		for t from tiles.staticItr()
			destroy t
		destroy effects
		destroy entities
		destroy tiles
		ttag.recycle()
		destroy parser
		destroy listparser

