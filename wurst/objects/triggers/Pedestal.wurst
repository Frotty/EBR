package Pedestal
import public PedestalObjects
import Assets
import BaseObject
import ClosureForGroups
import HashMap
import PlayerData
import FileIO
import Builder
import SyncWrapper
import TypeCasting
import CodeManager
import SeqWorker
import JsonParser
import TerrainBlocker
import LinkedList
import TileData

constant CHAR_STEPSIZE = 180

public class MemoryAccessPedestal extends StaticBaseObject
	static constant ENTITIES_KEY = "e"
	static constant TILES_KEY = "t"

	static MemoryAccessPedestal array lastRef 
	private LinkedList<Serializable> entities = new LinkedList<Serializable>()
	private LinkedList<TileData> tiles = new LinkedList<TileData>()
	private HashMap<Serializable, effect> effects = new HashMap<Serializable, effect>()
	private boolean syncingDone = true
	let parser = new JsonParser()
	
	construct(vec2 pos, player owner)
		super(pos, createUnit(owner, PED_ID, pos, angle(bj_UNIT_FACING)), 0, CODE_NULL, CODE_NULL)
		setPos(pos.toTile().toVec3())
		actor..addAbility(SAVE1_ID)..addAbility(LOAD1_ID)..addAbility(SAVE2_ID)..addAbility(SAVE3_ID)
		..addAbility(SELECT_TILE_ID)..addAbility(LOAD2_ID)..addAbility(SELECT_AOE_TILE_ID)
		..addAbility(LOAD3_ID)..addAbility(REMOVE_ID)..addAbility(SELECT_SINGLE_ID)
		clearQuestionmark()
		EventListener.add(actor, EVENT_PLAYER_UNIT_SPELL_CAST, () -> onCast())
		
	function addObj(Entity serializable, boolean removeIfExists)
		if serializable instanceof Escaper or serializable instanceof Builder or serializable instanceof MemoryAccessPedestal
			return
		if getRegionData(serializable.getPos()).canBuild(owner)
			let ownPos = pos.toVec2()
			let itr = entities.staticItr()
			for entity from itr
				if entity == serializable
					if removeIfExists
						destroy itr.remove()
					return
			// Isnt added yet
			entities.add(serializable)
			if serializable instanceof UnitEntity
				let ue = serializable castTo UnitEntity
				effects.put(serializable, ue.actor.addEffect(Other.roartarget, "overhead"))

	function addTile(vec2 tpos, boolean removeIfExists)
		let targPos = tpos.toTile()
		if getRegionData(targPos).canBuild(owner)
			let ownPos = pos.toVec2()
			let mpos = matrixpos(((targPos-ownPos).x / 128.).toInt(), ((targPos-ownPos).y / 128.).toInt())
			let itr = tiles.staticItr()
			for tile from itr
				if tile.offset == mpos
					if removeIfExists
						destroy itr.remove()
					return

			if getTileFromType(targPos) != Tile.UNWALKABLE
				tiles.add(new TileData(targPos, mpos))

	function loadSlot(int slotId)
		lastRef[owner.getId()] = this
		getSyncedFile(pData[owner.getId()], "dataSlot" + slotId.toString(), Filter(() -> onLoadSlotSynced()))

	static function onLoadSlotSynced()
		printLog(Loglevel.DEBUG, "synced")
		let pd = pData[getSyncedData().p.getId()]
		let ref = lastRef[pd.id]
		ref.syncingDone = true
		var jsonString = new BigString()
		var buildString = pd.syncPayload.syncedFile.read()
		while buildString != null
			jsonString.addString(buildString)
			buildString = pd.syncPayload.syncedFile.read()
		printLog(Loglevel.DEBUG, "Reconstructed")
		serializeOrigin = ref.pos.toVec2().toTile().toVec3()
		ref.parser.setInput(jsonString)
		ref.parser.parse((SeqCallback cb) -> begin
			ref.parser.output.getStringList(ENTITIES_KEY, ref.parser, (SeqCallback cb) -> begin
				cb.terminate()
				ref.loadEntities()
			end)
		end)
		

	function loadEntities()
		// TODO load entities

		// Load tiles
		parser.output.getStringList(TILES_KEY, parser, (SeqCallback cb) -> begin
			loadTiles((cb.customData castTo JsonParser).outputList)
			cb.terminate()
		end)

	function loadTiles(LinkedList<BigSubString> list)
		print("Loading tiles..")
		let td = new TileData()
		let bs = new BigString()
		
		var itr = list.staticItr()
		doSeq(1, (SeqCallback cb1) -> begin
			cb1.done = true
			if itr.hasNext()
				bs.reset()
				let next = itr.next()
				parser.setInput(bs..addSubString(next))
				parser.parse((SeqCallback cb2) -> begin
					td..deserialize(parser.output)
					parser.output.reset()
					cb1.doStep()
				end)
			else
				cb1.terminate()
				print("Tile loaded!")
		end)

	BigString tileString = new BigString()
	BigString entString = new BigString()

	int currentSlotId
	function saveSlot(int slotId)
		let itr = entities.staticItr()
		currentSlotId = slotId
		entString.reset()
		entString.addString(JSON_OPEN_ARRAY.token)
		doSeq(10, (SeqCallback cb) -> begin
			if itr.hasNext()
				itr.next().serialize().addToBigString(entString)
				if itr.hasNext()
					entString.addString(JSON_SIGN_COMMA.token)
				destroy itr.remove()
			else
				cb.terminate()
				entString.addString(JSON_CLOSE_ARRAY.token)
				nullTimer(() -> saveTileSeq())
		end)

	function saveTileSeq()
		tileString.reset()
		tileString.addString(JSON_OPEN_ARRAY.token)
		let itr = tiles.staticItr()
		doSeq(10, (SeqCallback cb) -> begin
			if itr.hasNext()
				itr.next().serialize().addToBigString(tileString)
				if itr.hasNext()
					tileString.addString(JSON_SIGN_COMMA.token)
				destroy itr.remove()
			else
				cb.terminate()
				tileString.addString(JSON_CLOSE_ARRAY.token)
				nullTimer(() -> saveFile())
		end)

	function saveFile()
		let json = new Json()
		let big = new BigString()
		json.addProperty(new Property(new BigSubString(ENTITIES_KEY), entString.asSubstring()))
		json.addProperty(new Property(new BigSubString(TILES_KEY), tileString.asSubstring()))
		
		json.addToBigString(big)
		
		if GetLocalPlayer() == owner
			let f = File.open(FOLDER_NAME, "dataSlot" + currentSlotId.toString(), Mode.WRITE)
			while big.getLength() > BIG_SUBSTRING_LEN
				f.write(big.getString(0, BIG_SUBSTRING_LEN))
				big.startoffset += BIG_SUBSTRING_LEN
			f.write(big.getString(0))
			f.close()

		destroy json
		destroy big

	function onCast()
		let id = GetSpellAbilityId()
		let tpos = getSpellTargetPos()
		switch id
			case SELECT_AOE_ID
				forUnitsInRange(tpos, AOE_PICK_RANGE, (unit u) -> begin
					if u != actor
						if u.getEntity() != null
							var ed = u.getEntity()
							if ed.owner == owner
								addObj(ed, false)
				end)
			case SELECT_SINGLE_ID
				if GetSpellTargetUnit().getEntity().owner == owner
					addObj(GetSpellTargetUnit().getEntity(), true)
			case SELECT_TILE_ID
				addTile(tpos, true)
			case SAVE1_ID
				saveSlot(1)
			case SAVE2_ID
				saveSlot(2)
			case SAVE3_ID
				saveSlot(3)
			case SAVE4_ID
				saveSlot(4)
			case LOAD1_ID
				loadSlot(1)
			case LOAD2_ID
				loadSlot(2)
			case LOAD3_ID
				loadSlot(3)
			case LOAD4_ID
				loadSlot(4)
			case SELECT_AOE_TILE_ID
				let val = (AOE_PICK_RANGE/128.).round()
				for x = -val to val
					for y = -val to val
						addTile((tpos+vec2(x*128.,y*128.)), false)

	ondestroy
		for t from tiles.staticItr()
			destroy t
		destroy effects
		destroy entities
		destroy tiles

