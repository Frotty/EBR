package Pedestal
import Assets
import BaseObject
import ClosureForGroups
import HashMap
import PlayerData
import FileIO
import SyncWrapper
import TerrainBlocker
import public PedestalObjects
import TypeCasting
import ClosureTimers
import CodeManager
import Json
import SeqWorker
import JsonParser

constant CHAR_STEPSIZE = 180

function vec2.toTile() returns vec2
	return vec2((this.x / 128.).round()*128. ,(this.y / 128.).round()*128.)

enum Tile
	UNWALKABLE
	WALKABLE
	LAVA
	POISON
	ICE_NORMAL
	ICE_DARK
	ICE_REVERSE

class TileData implements Serializable
	static constant X_KEY = "x"
	static constant Y_KEY = "y"
	static constant TYPE_KEY = "t"
	matrixpos offset
	vec2 pos
	effect fx
	Tile tile = Tile.WALKABLE

	construct()

	construct(vec2 realpos, matrixpos offset)
		this.pos = realpos
		this.offset = offset
		this.fx = addEffect(Other.vengeancemissile, pos)

	ondestroy
		fx.destr()

	override function serialize() returns Json
		this.tile = getTileFromType(pos)
		let json = new Json()
			..addProperty(new Property(X_KEY, offset.x.toString()))..addProperty(new Property(Y_KEY, offset.y.toString()))
		if tile != Tile.WALKABLE
			json..addProperty(new Property(TYPE_KEY, (getTileFromType(pos) castTo int).toString()))
		return json

	override function deserialize(Json json)
		offset = matrixpos(json.getInt(X_KEY),json.getInt(Y_KEY))
		pos = vec2(serializeOrigin.x + offset.x * 128.,serializeOrigin.y + offset.y * 128.).toTile()
		tile = json.getInt(TYPE_KEY) castTo Tile
		if tile == Tile.UNWALKABLE
			tile = Tile.WALKABLE
		let rdat = getRegionData(pos)
		switch tile
			case WALKABLE
				pos.setTerrainType(rdat.getTypeSet().walkableId, -1, 1, 0)
			case ICE_NORMAL
				pos.setTerrainType(CONTROLLABLEICE, -1, 1, 0)
			case ICE_DARK
				pos.setTerrainType(UNCONTROLLABLEICE, -1, 1, 0)
			case ICE_REVERSE
				pos.setTerrainType(REVICE, -1, 1, 0)
			case LAVA
				pos.setTerrainType(LAVA, -1, 1, 0)
			case POISON
				pos.setTerrainType(POISON, -1, 1, 0)
			default


function getTileFromType(vec2 pos) returns Tile
	let ttype = GetTerrainType(pos.x, pos.y)
	let rdat = getRegionData(pos)
	switch ttype
		case rdat.getTypeSet().walkableId
			return Tile.WALKABLE
		case REVICE
			return Tile.ICE_REVERSE
		case CONTROLLABLEICE
			return Tile.ICE_NORMAL
		case UNCONTROLLABLEICE
			return Tile.ICE_DARK
		case 1147958883
			return Tile.LAVA
		case POISON
			return Tile.POISON
	return Tile.UNWALKABLE

public class MemoryAccessPedestal extends StaticBaseObject
	static constant ENTITIES_KEY = "e"
	static constant TILES_KEY = "t"

	static MemoryAccessPedestal array lastRef 
	private LinkedList<Serializable> entities = new LinkedList<Serializable>()
	private LinkedList<TileData> tiles = new LinkedList<TileData>()
	private HashMap<Serializable, effect> effects = new HashMap<Serializable, effect>()
	private boolean syncingDone = true
	let parser = new JsonParser()
	
	construct(vec2 pos, player owner)
		super(pos, createUnit(owner, PED_ID, pos, angle(bj_UNIT_FACING)), 0, CODE_NULL, CODE_NULL)
		setPos(pos.toTile().toVec3())
		actor..addAbility(SAVE1_ID)..addAbility(LOAD1_ID)..addAbility(SAVE2_ID)..addAbility(SAVE3_ID)
		..addAbility(SAVE4_ID)..addAbility(SELECT_TILE_ID)..addAbility(LOAD2_ID)..addAbility(SELECT_AOE_TILE_ID)
		..addAbility(LOAD3_ID)..addAbility(LOAD4_ID)
		clearQuestionmark()
		EventListener.add(actor, EVENT_PLAYER_UNIT_SPELL_CAST, () -> onCast())
		
	function addObj(Serializable serializable)
		if serializable instanceof Escaper
			return
		if entities.contains(serializable)
			entities.remove(serializable)
			let ef = effects.get(serializable)
			if ef != null
				ef.destr()
		else
			entities.add(serializable)
			if serializable instanceof UnitEntity
				let ue = serializable castTo UnitEntity
				effects.put(serializable, ue.actor.addEffect(Other.roartarget, "overhead"))

	function addTile(vec2 tpos, boolean removeIfExiss)
		let targPos = tpos.toTile()
		let ownPos = pos.toVec2()
		let mpos = matrixpos(((targPos-ownPos).x / 128.).toInt(), ((targPos-ownPos).y / 128.).toInt())
		let itr = tiles.staticItr()
		for tile from itr
			if tile.offset == mpos
				if removeIfExiss
					destroy itr.remove()
				return

		if getTileFromType(targPos) != Tile.UNWALKABLE
			tiles.add(new TileData(targPos, mpos))

	function loadSlot(int slotId)
		lastRef[owner.getId()] = this
		getSyncedFile(pData[owner.getId()], "dataSlot" + slotId.toString(), Filter(() -> onLoadSlotSynced()))

	static function onLoadSlotSynced()
		printLog(Loglevel.DEBUG, "synced")
		let pd = pData[getSyncedData().p.getId()]
		let ref = lastRef[pd.id]
		ref.syncingDone = true
		var jsonString = new BigString()
		var buildString = pd.syncPayload.syncedFile.read()
		while buildString != null
			jsonString.addString(buildString)
			buildString = pd.syncPayload.syncedFile.read()
		printLog(Loglevel.DEBUG, "Reconstructed")
		serializeOrigin = ref.pos.toVec2().toTile().toVec3()
		ref.parser.setInput(jsonString)
		ref.parser.parse((SeqCallback cb) -> begin
			ref.parser.output.getStringList(ENTITIES_KEY, ref.parser, (SeqCallback cb) -> begin
				cb.terminate()
				ref.loadEntities()
			end)
		end)
		

	function loadEntities()
		// TODO load entities

		// Load tiles
		parser.output.getStringList(TILES_KEY, parser, (SeqCallback cb) -> begin
			loadTiles((cb.customData castTo JsonParser).outputList)
			cb.terminate()
		end)

	function loadTiles(LinkedList<BigSubString> list)
		print("Loading tiles..")
		let td = new TileData()
		let bs = new BigString()
		
		var itr = list.staticItr()
		doSeq(1, (SeqCallback cb1) -> begin
			cb1.done = true
			if itr.hasNext()
				bs.reset()
				let next = itr.next()
				parser.setInput(bs..addSubString(next))
				parser.parse((SeqCallback cb2) -> begin
					td..deserialize(parser.output)
					parser.output.reset()
					cb1.doStep()
				end)
			else
				cb1.terminate()
				print("Tile loaded!")
		end)

	BigString tileString = new BigString()
	BigString entString = new BigString()
	// function loadSeq()
	// 	let td = new TileData()
	// 	let tempJson = new Json()
	// 	
	// 	print("loading sequential: " + currentList.getSize().toString())
	// 	int i = 0
	// 	let itr = currentList.staticItr()
	// 	for tile from currentList.staticItr()
	// 		itr.remove()
	// 		if tile != null and tile.length() > 2
	// 			print("tile: " + i.toString() + " - " + tile)
	// 			// let tileJson = tempJson..fromString(tile)
	// 			// td..deserialize(tileJson)
	// 			tempJson.reset()
	// 		i++
	// 		if i >= 20
	// 			break
	// 	print("loaded tiles")
	// 	destroy tempJson
	// 	destroy td
			

	int currentSlotId
	function saveSlot(int slotId)
		let itr = entities.staticItr()
		currentSlotId = slotId
		entString.reset()
		entString.addString(JSON_OPEN_ARRAY.token)
		doSeq(10, (SeqCallback cb) -> begin
			if itr.hasNext()
				itr.next().serialize().addToBigString(entString)
				if itr.hasNext()
					entString.addString(JSON_SIGN_COMMA.token)
				destroy itr.remove()
			else
				cb.terminate()
				entString.addString(JSON_CLOSE_ARRAY.token)
				nullTimer(() -> saveTileSeq())
		end)

	function saveTileSeq()
		tileString.reset()
		tileString.addString(JSON_OPEN_ARRAY.token)
		let itr = tiles.staticItr()
		doSeq(10, (SeqCallback cb) -> begin
			if itr.hasNext()
				itr.next().serialize().addToBigString(tileString)
				if itr.hasNext()
					tileString.addString(JSON_SIGN_COMMA.token)
				destroy itr.remove()
			else
				cb.terminate()
				tileString.addString(JSON_CLOSE_ARRAY.token)
				nullTimer(() -> saveFile())
		end)

	function saveFile()
		let json = new Json()
		let big = new BigString()
		json.addProperty(new Property(new BigSubString(ENTITIES_KEY), entString.asSubstring()))
		json.addProperty(new Property(new BigSubString(TILES_KEY), tileString.asSubstring()))
		
		json.addToBigString(big)
		
		
		if GetLocalPlayer() == owner
			let f = File.open(FOLDER_NAME, "dataSlot" + currentSlotId.toString(), Mode.WRITE)
			while big.getLength() > BIG_SUBSTRING_LEN
				f.write(big.getString(0, BIG_SUBSTRING_LEN))
				big.startoffset += BIG_SUBSTRING_LEN
			f.write(big.getString(0))
			f.close()

		destroy json
		destroy big

	function onCast()
		let id = GetSpellAbilityId()
		let tpos = getSpellTargetPos()
		switch id
			case SELECT_AOE_ID
				forUnitsInRange(tpos, AOE_PICK_RANGE, (unit u) -> begin
					if u != actor
						if u.getEntity() != null
							var ed = u.getEntity()
							if ed.owner == owner
								addObj(ed)
				end)
			case SELECT_SINGLE_ID
				addObj(GetSpellTargetUnit().getEntity())
			case SELECT_TILE_ID
				addTile(tpos, true)
			case SAVE1_ID
				saveSlot(1)
			case SAVE2_ID
				saveSlot(2)
			case SAVE3_ID
				saveSlot(3)
			case SAVE4_ID
				saveSlot(4)
			case LOAD1_ID
				loadSlot(1)
			case LOAD2_ID
				loadSlot(2)
			case LOAD3_ID
				loadSlot(3)
			case LOAD4_ID
				loadSlot(4)
			case SELECT_AOE_TILE_ID
				let val = (AOE_PICK_RANGE/128.).round()
				for x = -val to val
					for y = -val to val
						addTile((tpos+vec2(x*128.,y*128.)), false)
