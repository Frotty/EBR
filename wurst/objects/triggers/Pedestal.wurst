package Pedestal
import initlater InstantBuild
import public PedestalObjects
import Assets
import BaseObject
import ClosureForGroups
import HashMap
import PlayerData
import FileIO
import Builder
import SyncWrapper
import CodeManager
import JsonParser
import TerrainBlocker
import TileData
import LZW

constant CHAR_STEPSIZE = 180

public class MemoryAccessPedestal extends StaticBaseObject
	static constant ENTITIES_KEY = "e"
	static constant TILES_KEY = "t"

	static MemoryAccessPedestal array lastRef 
	private LinkedList<Serializable> entities = new LinkedList<Serializable>()
	private LinkedList<TileData> tiles = new LinkedList<TileData>()
	private HashMap<Serializable, effect> effects = new HashMap<Serializable, effect>()
	private boolean syncingDone = true
	let parser = new JsonParser()
	let listparser = new JsonParser()
	
	construct(vec2 pos, player owner)
		super(pos, createUnit(owner, PED_ID, pos, angle(bj_UNIT_FACING)), 0, CODE_NULL, CODE_NULL)
		setPos(pos.toTile().toVec3())
		actor..addAbility(SAVE1_ID)..addAbility(LOAD1_ID)..addAbility(SAVE2_ID)..addAbility(SAVE3_ID)
		..addAbility(SELECT_TILE_ID)..addAbility(LOAD2_ID)..addAbility(SELECT_AOE_TILE_ID)
		..addAbility(LOAD3_ID)..addAbility(REMOVE_ID)..addAbility(SELECT_SINGLE_ID)
		clearQuestionmark()
		EventListener.add(actor, EVENT_PLAYER_UNIT_SPELL_CAST, () -> onCast())
		
	function addObj(Entity serializable, boolean removeIfExists)
		if serializable instanceof Escaper or serializable instanceof Builder or serializable instanceof MemoryAccessPedestal
			return
		if getRegionData(serializable.getPos()).canBuild(owner)
			let itr = entities.staticItr()
			for entity from itr
				if entity == serializable
					if removeIfExists
						destroy itr.remove()
					return
			// Isnt added yet
			entities.add(serializable)
			if serializable instanceof UnitEntity
				let ue = serializable castTo UnitEntity
				effects.put(serializable, ue.actor.addEffect(Other.roartarget, "overhead"))

	function addTile(vec2 tpos, boolean removeIfExists)
		let targPos = tpos.toTile()
		if getRegionData(targPos).canBuild(owner)
			let mpos = matrixpos((targPos.x / 128.).toInt(), (targPos.y / 128.).toInt())
			let itr = tiles.staticItr()
			for tile from itr
				if tile.offset == mpos
					if removeIfExists
						destroy itr.remove()
					return

			if getTileFromType(targPos) != Tile.UNWALKABLE
				tiles.add(new TileData(targPos, mpos, owner))

	function loadSlot(int slotId)
		lastRef[owner.getId()] = this
		getSyncedFile(pData[owner.getId()], "dataSlot" + slotId.toString(), Filter(() -> onLoadSlotSynced()))

	static function onLoadSlotSynced()
		printLog(Loglevel.DEBUG, "synced")
		let pd = pData[getSyncedData().p.getId()]
		let ref = lastRef[pd.id]
		ref.syncingDone = true
		var compressedString = new BigString()
		var buildString = pd.syncPayload.syncedFile.read()
		while buildString != null
			compressedString.addString(buildString)
			buildString = pd.syncPayload.syncedFile.read()
		printLog(Loglevel.DEBUG, "Reconstructed")
		serializeOrigin = ref.pos.toVec2().toTile().toVec3()

		decompress(compressedString, (PayloadCallback cb1) -> begin
			ref.parser.setInput(cb1.customData castTo BigString)
			ref.parser.parse((PayloadCallback cb2) -> begin
				ref.parser.output.getStringList(ENTITIES_KEY, ref.listparser, (PayloadCallback cb3) -> begin
					ref.loadEntities((cb3.customData castTo JsonParser).outputList)
				end)
			end)
		end)


	function loadEntities(LinkedList<BigSubString> list)
		// load entities
		print("Loading Entities")
		let bs = new BigString()
		var itr = list.staticItr()
		doSeq(1, (SeqCallback cb) -> begin
			if itr.hasNext()
				bs.reset()
				let next = itr.next()
				print("Loading Entity length: " + next.getSingleLength().toString())
				listparser.setInput(bs..addSubString(next))
				listparser.parse((PayloadCallback cb2) -> begin
					let json = listparser.output
					let npos = vec2(json.getReal(KEY_X), json.getReal(KEY_Y))
					let tId = json.getInt(KEY_TYPE)
					newObjectFromId(owner,	serializeOrigin.toVec2() + npos, tId)..deserialize(listparser.output)
					listparser.output.reset()
					cb.doStep()
				end)
			else
				cb.terminate()
				destroy bs
				print("Entites loaded!")
				// Load tiles
				parser.output.getStringList(TILES_KEY, listparser, (PayloadCallback cb) -> begin
					loadTiles(listparser.outputList)
				end)
		end)

	function loadTiles(LinkedList<BigSubString> list)
		print("Loading tiles..")
		let td = new TileData()
		let bs = new BigString()
		
		var itr = list.staticItr()
		doSeq(1, (SeqCallback cb1) -> begin
			if itr.hasNext()
				bs.reset()
				let next = itr.next()
				parser.setInput(bs..addSubString(next))
				parser.parse((PayloadCallback cb2) -> begin
					print("load tile")
					td..deserialize(parser.output)
					parser.output.reset()
					cb1.doStep()
				end)
			else
				cb1.terminate()
				print("Tiles loaded!")
		end)

	BigString tileString = new BigString()
	BigString entString = new BigString()

	int currentSlotId
	function saveSlot(int slotId)
		serializeOrigin = pos.toVec2().toTile().toVec3()
		let itr = entities.staticItr()
		currentSlotId = slotId
		entString.reset()
		entString.addString(JSON_OPEN_ARRAY.token)
		doSeq(10, (SeqCallback cb) -> begin
			if itr.hasNext()
				let json = itr.next().serialize()
				json.addToBigString(entString)
				destroy json
				if itr.hasNext()
					entString.addString(JSON_SIGN_COMMA.token)
				destroy itr.remove()
			else
				cb.terminate()
				entString.addString(JSON_CLOSE_ARRAY.token)
				saveTileSeq()
		end)

	function saveTileSeq()
		tileString.reset()
		tileString.addString(JSON_OPEN_ARRAY.token)
		let itr = tiles.staticItr()
		doSeq(10, (SeqCallback cb) -> begin
			if itr.hasNext()
				itr.next().serialize().addToBigString(tileString)
				if itr.hasNext()
					tileString.addString(JSON_SIGN_COMMA.token)
				destroy itr.remove()
			else
				cb.terminate()
				tileString.addString(JSON_CLOSE_ARRAY.token)
				print("added closeing bracket")
				tileString.debugPrint()
				saveFile()
		end)

	function saveFile()
		let json = new Json()
		let big = new BigString()
		json.addProperty(new Property(new BigSubString(ENTITIES_KEY), entString.asSubstring()))
		json.addProperty(new Property(new BigSubString(TILES_KEY), tileString.asSubstring()))
		
		json.addToBigString(big)
		destroy json
		compress(big, (PayloadCallback cb) -> begin
			let compressedData = cb.customData castTo BigString
			if GetLocalPlayer() == owner
				let f = File.open(FOLDER_NAME, "dataSlot" + currentSlotId.toString(), Mode.WRITE)
				while compressedData.getLength() > BIG_SUBSTRING_LEN
					f.write(compressedData.getString(0, BIG_SUBSTRING_LEN))
					compressedData.startoffset += BIG_SUBSTRING_LEN
				f.write(compressedData.getString(0))
				f.close()

			
			destroy big
		end)
		
		

	function onCast()
		let id = GetSpellAbilityId()
		let tpos = getSpellTargetPos()
		switch id
			case SELECT_AOE_ID
				forUnitsInRange(tpos, AOE_PICK_RANGE, (unit u) -> begin
					if u != actor
						if u.getEntity() != null
							var ed = u.getEntity()
							if ed.owner == owner
								addObj(ed, false)
				end)
			case SELECT_SINGLE_ID
				if GetSpellTargetUnit().getEntity().owner == owner
					addObj(GetSpellTargetUnit().getEntity(), true)
			case SELECT_TILE_ID
				addTile(tpos, true)
			case SAVE1_ID
				saveSlot(1)
			case SAVE2_ID
				saveSlot(2)
			case SAVE3_ID
				saveSlot(3)
			case SAVE4_ID
				saveSlot(4)
			case LOAD1_ID
				loadSlot(1)
			case LOAD2_ID
				loadSlot(2)
			case LOAD3_ID
				loadSlot(3)
			case LOAD4_ID
				loadSlot(4)
			case SELECT_AOE_TILE_ID
				let val = (AOE_PICK_RANGE/128.).round()
				for x = -val to val
					for y = -val to val
						addTile((tpos+vec2(x*128.,y*128.)), false)

	ondestroy
		for t from tiles.staticItr()
			destroy t
		destroy effects
		destroy entities
		destroy tiles

