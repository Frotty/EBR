package Spinner
import SetupObject
import Preloader
import Obstacle

constant SPINNER_ID      = 'h01M'
constant SPELL_ID        = 'A01B'
constant SPELL2_ID       = 'A04M'
constant INC_ID          = 'A01F'
constant DEC_ID          = 'A01G'	
constant CINC_ID          = 'A06K'
constant CDEC_ID          = 'A06L'	
constant SINC_ID          = 'A06M'
constant SDEC_ID          = 'A06N'	

class SpinNode
	SpinNode next = null
	SpinNode prev = null
	SetupObject obj
	real angl
	real dist
	
	construct(SetupObject ent, real ang, real dist)
		obj = ent
		angl = ang
		this.dist = dist
	
	ondestroy
		if next != null
			next.prev = prev
		if prev != null
			prev.next = next
		if not obj.done and obj.actor != null
			obj.setup.addAbility(removeObject)

public class Spinner extends SetupObject
	SpinNode firstNode = null
	ConfigValue spinSpeed = new ConfigValue(2 * DEGTORAD, 0.25 * DEGTORAD, "Spinspeed")
	ConfigValue cosFactor = new ConfigValue(1, 0.1, "Cos-Factor")
	ConfigValue sinFactor = new ConfigValue(1, 0.1, "Sin-Factor")

	construct(unit existing)
		super(getUnit(existing.getOwner(), SPINNER_ID, existing.getPos(), angle(0), this), existing, 0)
		sleeps = false
		setup.addAbility(turnOff)
		EventListener.add(setup, EVENT_PLAYER_UNIT_SPELL_CAST, () -> onCast())

	construct(vec2 pos, player owner)
		super(getUnit(owner, SPINNER_ID, pos, angle(0), this), getUnit(owner, SPINNER_ID, pos, angle(0), this), 0)
		sleeps = false
		setup.addAbility(turnOff)
		EventListener.add(setup, EVENT_PLAYER_UNIT_SPELL_CAST, () -> onCast())
		
	override function update()
		super.update()
		let speed = spinSpeed.get()
		var node = firstNode
		while node != null
			if not node.obj.done and node.obj.actor != null
				node.obj.setXY(vec3(pos.x + node.dist * Cos(node.angl+speed) * cosFactor.get(), pos.y + node.dist * Sin(node.angl+speed) * sinFactor.get(), 0.))
				if enabled
					node.angl += speed
			else
				destroy node
				if node == firstNode
					firstNode = node.next
			node = node.next
			
	function checkObj(Entity e)
		if e instanceof SetupObject and not e instanceof Obstacle
			var dobj = e castTo SetupObject
			boolean isNew = true
			var node = firstNode
			while node != null
				if node.obj == dobj
					isNew = false
					if firstNode == node
						firstNode = node.next
					destroy node
					break
				node = node.next
			if isNew and (dobj.setup.hasAbility(removeObject) or dobj.owner == STAFF_PLAYER)
				dobj.setup.removeAbility(removeObject)
				let newnode = new SpinNode(dobj, getPos().angleTo2d(dobj.getPos()).radians(), getPos().distanceTo(dobj.getPos()))
				if firstNode != null
					firstNode.prev = newnode
					newnode.next = firstNode
				firstNode = newnode

	ondestroy
		var node = firstNode
		firstNode = null
		while node != null
			destroy node
			node = node.next
	

	function onCast()
		let id = GetSpellAbilityId()
		switch id
			case turnOn
				setEnabled(true)
			case turnOff
				setEnabled(false)
			case SPELL_ID
				var u = GetSpellTargetUnit()
				var data = u.getUserData() castTo UnitEntity
				if owner == owner
					checkObj(data)
			case SPELL2_ID
				var tx = GetSpellTargetX()
				var ty = GetSpellTargetY()
				GroupEnumUnitsInRange(ENUM_GROUP, tx, ty, 300., null)
				for gu in ENUM_GROUP
					if gu != actor and gu != setup
						if gu.getUserData() > 0
							var ed = gu.getEntity()
							if ed.owner == owner
								checkObj(gu.getEntity())
				ENUM_GROUP.clear()
			case INC_ID
				spinSpeed.increment(this, 10 * DEGTORAD)
			case DEC_ID
				spinSpeed.decrement(this, -10 * DEGTORAD)
			case CINC_ID
				cosFactor.increment(this, 1)
			case CDEC_ID
				cosFactor.decrement(this, 0)
			case SINC_ID
				sinFactor.increment(this, 1)
			case SDEC_ID
				sinFactor.decrement(this, 0)
			
			

	override function serialize() returns Json
		let json = super.serialize()
		json.addProperty(new Property(KEY_TYPE, SPINNER_INDEX.toString()))
		return json

init
	preloadAbility(SPELL_ID)
	preloadAbility(SPELL2_ID)
	preloadAbility(INC_ID)
	preloadAbility(DEC_ID)
		
