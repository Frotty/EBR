package Waypoint
import BaseObject
import Escaper
import SetupObject
import TeleporterTarget
import Builder

constant int 	WAYPOINT_ID   = 'n004'
constant int INC_ID = 'A054'
constant int DEC_ID = 'A055'
constant int WISP_ID = 'A027'
constant INTERVAL = .25

	
constant real 	EVENT_RADIUS	= 32.

class DelayData
	UnitEntity entity
	vec2 pos
	
	construct(UnitEntity k, vec2 t)
		entity = k
		pos = t

public class Waypoint extends StaticBaseObject
	real delay = 0.
	boolean wisps = true
	
	construct( vec2 pos, player owner )
		super( pos, CreateUnit(owner, WAYPOINT_ID, pos.x, pos.y, 0.), EVENT_RADIUS, function Waypoint.orderMove, function Waypoint.isProper2 )
		EventListener.add(actor, EVENT_PLAYER_UNIT_SPELL_CAST, () -> onCast())
		printLog(Loglevel.DEBUG, "On create waypoint")
		
	static function orderMove()
		unit source = GetTriggeringTrigger().getSource()
		unit u = GetTriggerUnit()
		Entity e = u.getEntity()
		thistype obj = source.getUserData() castTo thistype
		let rallyPos = obj.getRallyPoint() + vec2(-0.01,0)
		if obj.owner == u.getOwner() and e instanceof UnitEntity and not e instanceof Escaper and not e instanceof Builder
			var data = e castTo UnitEntity
			if not obj.wisps and data instanceof TeleporterTarget
				return
			if obj.delay < INTERVAL
				if data instanceof SetupObject
					(data castTo SetupObject).setup.issuePointOrder("move", rallyPos.toVec2())
					(data castTo SetupObject).actor.issuePointOrder("move", rallyPos.toVec2())
				else
					data.actor.issuePointOrder("move", rallyPos.toVec2())
			else
				u.issueImmediateOrder("stop")
				getTimer()..start(obj.delay, function Waypoint.delayMove)..setData(new DelayData(data, vec2(rallyPos.x,rallyPos.y))castTo int)
				
	static function delayMove()
		var t = GetExpiredTimer()
		DelayData data = t.getData() castTo DelayData
		if data.entity instanceof SetupObject
			(data.entity castTo SetupObject).setup.issuePointOrder("move", data.pos)
			(data.entity castTo SetupObject).actor.issuePointOrder("move", data.pos)
		else
			data.entity.actor.issuePointOrder("move", data.pos)
		destroy data
		t.release()

	static function isProper2() returns boolean
		return true


	function onCast()
		let id = GetSpellAbilityId()
		switch id
			case INC_ID
				if delay < 5.
					delay += INTERVAL
					createTTEx(pos, vec2(0,0.05), "Delay " + delay.toString(), 10,  2., colorA(255,255,255,0), owner  )
				else
					createTTEx(pos, vec2(0,0.05), "Maximum Delay", 10,  2., colorA(255,255,255,0), owner  )
			case DEC_ID
				if delay >= INTERVAL
					delay -= INTERVAL
					createTTEx(pos, vec2(0,0.05), "Delay " + delay.toString(), 10,  2., colorA(255,255,255,0), owner  )
				else
					createTTEx(pos, vec2(0,0.05), "Minimum Delay", 10,  2., colorA(255,255,255,0), owner  )
			case WISP_ID
				if wisps
					wisps = false
					createTTEx(pos, vec2(0,0.05), "Wisps |cffAD0821inactive", 10,  2., colorA(255,255,255,0), owner  )
				else
					wisps = true
					createTTEx(pos, vec2(0,0.05), "Wisps |cff08BD52active", 10,  2., colorA(255,255,255,0), owner  )
