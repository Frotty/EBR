package Waypoint
import BaseObject
import Escaper
import ObjectTarget
import Builder
import WaypointObjects
import ClosureTimers

constant INTERVAL = .25
constant EVENT_RADIUS = 32.

public class Waypoint extends StaticBaseObject
	real delay = 0.
	boolean wisps = true

	//logic
	Waypoint andPartner = null
	boolean ready = false
	
	construct( vec2 pos, player owner )
		super( pos, CreateUnit(owner, WAYPOINT_ID, pos.x, pos.y, 0.), EVENT_RADIUS, function Waypoint.onInRange, null)

	construct(unit existing)
		super( existing.getPos(), existing, EVENT_RADIUS, function Waypoint.onInRange, null)

	function orderLogicMove()
		let rallyPos = getRallyPoint() + vec2(0.001,0)
		GroupEnumUnitsInRange(ENUM_GROUP, pos.x, pos.y, radius+48., null)
		for u from ENUM_GROUP
			let data = u.getEntity()
			if owner == data.owner and not data instanceof Escaper and not data instanceof Builder and not data instanceof StaticBaseObject
				if data instanceof SetupObject
					(data castTo SetupObject).setup.issuePointOrder("move", rallyPos.toVec2())
				else
					data.actor.issuePointOrder("move", rallyPos.toVec2())

	function onEnter(unit entry)
		Entity e = entry.getEntity()
		let rallyPos = getRallyPoint() + vec2(0.001,0)
		if owner == e.owner and e instanceof UnitEntity and not e instanceof Escaper and not e instanceof Builder
			if e instanceof SetupObject
				if not (e castTo SetupObject).setup.hasAbility(REMOVE_OBJECT_ID)
					return
			var data = e castTo UnitEntity
			if not wisps and data instanceof ObjectTarget
				return
			if andPartner != null
				if not ready
					ready = true
					if andPartner.ready
						andPartner.orderLogicMove()
						orderLogicMove()
						andPartner.ready = false
						ready = false
			else if delay < INTERVAL
				if data instanceof SetupObject and (data castTo SetupObject).setup != (data castTo SetupObject).actor
					(data castTo SetupObject).setup.issuePointOrder("move", rallyPos.toVec2())
				else
					data.actor.issuePointOrder("move", rallyPos.toVec2())
			else
				doAfter(delay, () -> delayMove(data, rallyPos.toVec2()))

	override function onCast()
		super.onCast()
		let id = GetSpellAbilityId()
		switch id
			case INCREASE_DELAY_ID
				if delay < 5.
					delay += INTERVAL
					createFText(pos, vec2(0,0.05), "Delay " + delay.toString(), 10,  2., colorA(255,255,255,0), owner  )
				else
					createFText(pos, vec2(0,0.05), "Maximum Delay", 10,  2., colorA(255,255,255,0), owner  )
			case DECREASE_DELAY_ID
				if delay >= INTERVAL
					delay -= INTERVAL
					createFText(pos, vec2(0,0.05), "Delay " + delay.toString(), 10,  2., colorA(255,255,255,0), owner  )
				else
					createFText(pos, vec2(0,0.05), "Minimum Delay", 10,  2., colorA(255,255,255,0), owner  )
			case NO_WISPS_ID
				if wisps
					wisps = false
					createFText(pos, vec2(0,0.05), "Wisps |cffAD0821inactive", 10,  2., colorA(255,255,255,0), owner  )
				else
					wisps = true
					createFText(pos, vec2(0,0.05), "Wisps |cff08BD52active", 10,  2., colorA(255,255,255,0), owner  )
			case AND_CONNECTION_ID
				let target = GetSpellTargetUnit().getEntity()
				if target != null and target instanceof Waypoint
					andPartner = target castTo Waypoint
					andPartner.andPartner = this
					createFText(target.getPos(), vec2(0,0.1), "|cff0873C5Linked", 9., 1.5, colorA(255,255,255,255), owner)
				else
					andPartner = null
	
	static function delayMove(UnitEntity entity, vec2 pos)
		if entity instanceof SetupObject
			(entity castTo SetupObject).setup.issuePointOrder("move", pos)
		else
			entity.actor.issuePointOrder("move", pos)

	static function onInRange()
		unit source = GetTriggeringTrigger().getSource()
		thistype obj = source.getUserData() castTo thistype
		obj.onEnter(GetTriggerUnit())

	override function serialize() returns Json
		let json = super.serialize()
		json..addProperty(new Property(KEY_TYPE, WAYPOINT_INDEX.toString()))
		return json

