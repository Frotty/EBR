package Waypoint
import BaseObject
import Escaper
import TeleporterTarget
import Builder

constant int INC_ID = 'A054'
constant int DEC_ID = 'A055'
constant int WISP_ID = 'A027'
constant AND_ID = 'A08H'
constant INTERVAL = .25
constant real 	EVENT_RADIUS	= 32.

class DelayData
	UnitEntity entity
	vec2 pos
	
	construct(UnitEntity k, vec2 t)
		entity = k
		pos = t

public class Waypoint extends StaticBaseObject
	real delay = 0.
	boolean wisps = true

	//logic
	Waypoint andPartner = null
	boolean ready = false
	
	construct( vec2 pos, player owner )
		super( pos, CreateUnit(owner, waypoint, pos.x, pos.y, 0.), EVENT_RADIUS, function Waypoint.onInRange, CODE_NULL )
		actor..addAbility(turnOff)

	construct(unit existing)
		super( existing.getPos(), existing, EVENT_RADIUS, function Waypoint.onInRange, CODE_NULL )
		actor..addAbility(turnOff)

	function orderLogicMove()
		let rallyPos = getRallyPoint() + vec2(0.001,0)
		GroupEnumUnitsInRange(ENUM_GROUP, pos.x, pos.y, radius+48., Condition(() -> true))
		for u from ENUM_GROUP
			let data = u.getEntity() castTo UnitEntity
			if owner == data.owner and not data instanceof Escaper and not data instanceof Builder and not data instanceof StaticBaseObject
				if data instanceof SetupObject
					(data castTo SetupObject).setup.issuePointOrder("move", rallyPos.toVec2())
					(data castTo SetupObject).actor.issuePointOrder("move", rallyPos.toVec2())
				else
					data.actor.issuePointOrder("move", rallyPos.toVec2())

	function onEnter(unit entry)
		Entity e = entry.getEntity()
		let rallyPos = getRallyPoint() + vec2(0.001,0)
		if owner == e.owner and e instanceof UnitEntity and not e instanceof Escaper and not e instanceof Builder
			if e instanceof SetupObject
				if not (e castTo SetupObject).setup.hasAbility(removeObject)
					return
			var data = e castTo UnitEntity
			if not wisps and data instanceof TeleporterTarget
				return
			if andPartner != null
				if not ready
					ready = true
					if andPartner.ready
						andPartner.orderLogicMove()
						orderLogicMove()
						andPartner.ready = false
						ready = false
			else if delay < INTERVAL
				if data instanceof SetupObject
					(data castTo SetupObject).setup.issuePointOrder("move", rallyPos.toVec2())
					(data castTo SetupObject).actor.issuePointOrder("move", rallyPos.toVec2())
				else
					data.actor.issuePointOrder("move", rallyPos.toVec2())
			else
				getTimer()..start(delay, function Waypoint.delayMove)..setData(new DelayData(data, vec2(rallyPos.x,rallyPos.y))castTo int)

	override function onCast()
		super.onCast()
		let id = GetSpellAbilityId()
		switch id
			case INC_ID
				if delay < 5.
					delay += INTERVAL
					createFText(pos, vec2(0,0.05), "Delay " + delay.toString(), 10,  2., colorA(255,255,255,0), owner  )
				else
					createFText(pos, vec2(0,0.05), "Maximum Delay", 10,  2., colorA(255,255,255,0), owner  )
			case DEC_ID
				if delay >= INTERVAL
					delay -= INTERVAL
					createFText(pos, vec2(0,0.05), "Delay " + delay.toString(), 10,  2., colorA(255,255,255,0), owner  )
				else
					createFText(pos, vec2(0,0.05), "Minimum Delay", 10,  2., colorA(255,255,255,0), owner  )
			case WISP_ID
				if wisps
					wisps = false
					createFText(pos, vec2(0,0.05), "Wisps |cffAD0821inactive", 10,  2., colorA(255,255,255,0), owner  )
				else
					wisps = true
					createFText(pos, vec2(0,0.05), "Wisps |cff08BD52active", 10,  2., colorA(255,255,255,0), owner  )
			case AND_ID
				let target = GetSpellTargetUnit().getEntity()
				if target != null and target instanceof Waypoint
					andPartner = target castTo Waypoint
					andPartner.andPartner = this
					createFText(target.getPos(), vec2(0,0.1), "|cff0873C5Linked", 9., 1.5, colorA(255,255,255,255), owner)
				else
					andPartner = null
	
	static function delayMove()
		var t = GetExpiredTimer()
		DelayData data = t.getData() castTo DelayData
		if data.entity instanceof SetupObject
			(data.entity castTo SetupObject).setup.issuePointOrder("move", data.pos)
			(data.entity castTo SetupObject).actor.issuePointOrder("move", data.pos)
		else
			data.entity.actor.issuePointOrder("move", data.pos)
		destroy data
		t.release()

	static function onInRange()
		unit source = GetTriggeringTrigger().getSource()
		thistype obj = source.getUserData() castTo thistype
		obj.onEnter(GetTriggerUnit())

	override function serialize() returns Json
		let json = super.serialize()
		json..addProperty(new Property(KEY_TYPE, WAYPOINT_INDEX.toString()))
		return json


