package Sync2
import LinkedListModule
import SyncInteger
/***************************************************************
*
*   v1.2.1, by TriggerHappy
*   ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
*
*   This library allows you to quickly synchronize async data such as,
*   camera position, or a the contents of a file, to all players
*   in the map by using the game cache.
*
*   Full Documentation: -http://www.hiveworkshop.com/forums/pastebin.php?id=p4f84s
*
***************************************************************/

// characters that can be synced (ascii)
constant string ALPHABET                    = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~`"

// safe characters for use in game cache keys
// (case sensitive)
constant string SAFE_KEYS                   = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`{|}~`"

// how fast the buffer updates
constant real UPDATE_PERIOD                 = 0.03125

// size of the alphabet
constant integer ALPHABET_BASE              = StringLength(ALPHABET)

// stop reading the string buffer when reaching this char
constant string TERM_CHAR                   = "`"

// maximum number of strings *per instance*
constant integer MAX_STRINGS                = 8192

// filenames for gc
constant string CACHE_FILE                  = "i.w3v"
constant string CACHE_FILE_STR              = "s.w3v"

// don't edit below this line
constant real EVENT_SYNC_CACHE       = 3
constant integer SYNC_ERROR_TIMEOUT     = 1
constant integer SYNC_ERROR_PLAYERLEFT  = 2

//**************************************************************

public function GetSyncedData() returns SyncData
	return SyncData.Last

public function I2Char(string alphabet, integer i) returns string
	return SubString(alphabet, i, i + 1)

public function Char2I(string alphabet, string c) returns integer
	integer i = 0
	string s
	integer l = StringLength(alphabet)
	while i < l
		s = I2Char(alphabet, i)
		if (s == c)
			return i
		i++
	return 0

public function ConvertBase(string alphabet, integer ip) returns string
	var i = ip
	integer b
	string s = ""
	integer l = StringLength(alphabet)
	if i < l
		return I2Char(alphabet, i)
	while i > 0
		b = i - ( i div l ) * l
		s = I2Char(alphabet, b) + s
		i = i div l
	return s

public function PopulateString(string sp, integer makeLen) returns string
	var s = sp
	integer i = 0
	integer l = StringLength(s)
	if (l == makeLen)
		return s
	l = makeLen-l
	while i <= l
		s = s + TERM_CHAR
		i = i + 1
	return s

//**************************************************************

// string table keys
constant integer KEY_STR_POS = (0*MAX_STRINGS)
constant integer KEY_STR_LEN = (1*MAX_STRINGS)

// pending data storage space
constant integer KEY_STR_CACHE = (2*MAX_STRINGS)

public class SyncData
	use LinkedListModule

	real timeout
	filterfunc onComplete
	filterfunc onError
	filterfunc onUpdate

	integer lastError

	player fromP

	real timeStarted
	real timeFinished
	real timeElapsed

	integer intCount
	integer boolCount
	integer strCount
	integer realCount
	integer playersDone

	boolean buffering
	
	static boolean Initialized = false
	static SyncData Last        = null
	static player LocalPlayer
	static integer LocalPlayerID

	private static integer Running   = 0
	private static real timeCounter  = 0.00
	private static trigger EventTrig = CreateTrigger()

	private static hashtable Table
	private static gamecache array Cache
	private static integer array PendingCount
	private static timer Elapsed
	private static timer BufferTimer

	private integer strBufferLen
	private trigger eventTrig
	private string mkey
	private boolean localFinished

	private static thistype first

	private function resetVars()
		this.intCount       = 0
		this.strCount       = 0
		this.boolCount      = 0
		this.realCount      = 0
		this.playersDone    = 0
		this.strBufferLen   = 0
		this.timeStarted    = 0
		this.timeFinished   = 0
		this.lastError      = 0
		this.onComplete     = null
		this.onError        = null
		this.onUpdate       = null
		this.timeout        = 0.00
		this.buffering      = false
		this.localFinished  = false 

	private static function getKey(integer pos) returns string
		string position=""
		
		if (HaveSavedString(Table, KEY_STR_CACHE, pos))
			return LoadStr(Table, KEY_STR_CACHE, pos)
		
		position = ConvertBase(SAFE_KEYS, pos)
		SaveStr(Table, KEY_STR_CACHE, pos, position)
		
		return position
	
	construct(player fromP)

		// Player has to be playing because of GetLocalPlayer use.
		if (GetPlayerController(fromP) != MAP_CONTROL_USER or GetPlayerSlotState(fromP) != PLAYER_SLOT_STATE_PLAYING)

	
		this.fromP   = fromP
		this.mkey   = getKey((this castTo int)-1)

		this.resetVars()

	function refresh()
		for i = 0 to bj_MAX_PLAYER_SLOTS-1
			let p = i

			RemoveSavedInteger(Table, (this castTo int), KEY_STR_POS + p)
			RemoveSavedInteger(Table, (this castTo int), KEY_STR_LEN + p)
			RemoveSavedBoolean(Table, p, (this castTo int)) // playerdone

		FlushStoredMission(Cache[0], this.mkey)
		FlushStoredMission(Cache[1], this.mkey)

		this.resetVars()

	ondestroy
		if (this.eventTrig != null)
			DestroyTrigger(this.eventTrig)
			this.eventTrig=null

		this.refresh()

		this.next.prev = this.prev
		this.prev.next = this.next
	
	function hasInt(integer index) returns boolean
		return HaveStoredInteger(Cache[0], this.mkey, getKey(index))

	function hasReal(integer index) returns boolean
		return HaveStoredReal(Cache[0], this.mkey, getKey(index))

	function hasBool(integer index) returns boolean
		return HaveStoredBoolean(Cache[0], this.mkey, getKey(index))

	function hasString(integer index) returns boolean
		integer i = LoadInteger(Table, (this castTo int), KEY_STR_POS+index)
		if (index > 0 and i == 0)
			return false
		return HaveStoredInteger(Cache[1], this.mkey, getKey(i + LoadInteger(Table, (this castTo int), KEY_STR_LEN+index)))
	
	function addInt(integer i)
		string position=getKey(intCount)
		
		if (LocalPlayer == this.fromP)
			StoreInteger(Cache[0], this.mkey, position, i)
		
		intCount=intCount+1

	function addReal(real i)
		string position=getKey(realCount)
		
		if (LocalPlayer == this.fromP)
			StoreReal(Cache[0], this.mkey, position, i)
		
		realCount=realCount+1

	function addBool(boolean flag)
		string position=getKey(boolCount)
		
		if (LocalPlayer == this.fromP)
			StoreBoolean(Cache[0], this.mkey, position, flag)
		
		boolCount=boolCount+1

	// SyncStoredString doesn't work
	function addString(string sp, integer length)
		var s = sp
		string position
		integer i = 0
		integer strPos = 0
		integer strLen = 0

		if (StringLength(s) < length)
			s = PopulateString(s, length)
	
		// store the string position in the table
		if (strCount == 0)
			SaveInteger(Table, (this castTo int), KEY_STR_POS, 0)
		else
			strLen = LoadInteger(Table, (this castTo int), KEY_STR_LEN + (strCount-1)) + 1
			strPos = LoadInteger(Table, (this castTo int), KEY_STR_POS + (strCount-1)) + strLen

			SaveInteger(Table, (this castTo int), KEY_STR_POS + strCount, strPos)

		// convert each character in the string to an integer
		while i <= length

			position = getKey(strPos + i)

			if (LocalPlayer == this.fromP)
				StoreInteger(Cache[1], this.mkey, position, Char2I(ALPHABET, SubString(s, i, i + 1)))

			i = i + 1

		strBufferLen = strBufferLen + length
		SaveInteger(Table, (this castTo int), KEY_STR_LEN+strCount, length) // store the length as well
		strCount=strCount+1

	function readInt(integer index) returns integer
		return GetStoredInteger(Cache[0], this.mkey, getKey(index))

	function readReal(integer index) returns real
		return GetStoredReal(Cache[0], this.mkey, getKey(index))

	function readBool( integer index) returns boolean
		return GetStoredBoolean(Cache[0], this.mkey, getKey(index))

	function readString(integer index) returns string
		string s = ""
		string c
		integer i = 0
		integer strLen = LoadInteger(Table, (this castTo int), KEY_STR_LEN+index)
		integer strPos
		
		if (not hasString(index))
			return null

		strLen = LoadInteger(Table, (this castTo int), KEY_STR_LEN+index)
		strPos = LoadInteger(Table, (this castTo int), KEY_STR_POS+index)
		
		while i <= strLen
			
			c = I2Char(ALPHABET, GetStoredInteger(Cache[1], this.mkey, getKey(strPos + i)))

			if (c == TERM_CHAR)
				return s

			s = s + c
			i = i + 1

		return s

	function addEventListener(code func)
		if (this.eventTrig == null)
			this.eventTrig = CreateTrigger()
		TriggerAddCondition(this.eventTrig, Filter(func))

	static function gameTime() returns real
		return timeCounter + TimerGetElapsed(Elapsed)

	private function fireEvent(filterfunc func)
		print("fire events")
		Last = this

		TriggerAddCondition(EventTrig, func)
		TriggerEvaluate(EventTrig)
		TriggerClearConditions(EventTrig)

	private function error(integer errorId)
		this.lastError = errorId

		if (this.onError != null)
			this.fireEvent(this.onError)

		this.buffering = false
	
	private static function readBuffer()
		boolean b = true
		integer i = 0
		thistype data = SyncData.first

		while data != null
			// find the nearest instance that is still buffering
			if data.buffering
				print("read buffer")
				data.timeElapsed = data.timeElapsed + UPDATE_PERIOD

				if (data.onUpdate != null)
					data.fireEvent(data.onUpdate)

				if (data.timeout > 0 and data.timeElapsed > data.timeout)
					data.error(SYNC_ERROR_TIMEOUT)

				// if the player has left, destroy the instance
				if (GetPlayerSlotState(data.fromP) != PLAYER_SLOT_STATE_PLAYING)
					data.error(SYNC_ERROR_PLAYERLEFT)
					destroy data

				b = true

				// make sure all integers have been synced
				if (data.intCount > 0 and  not data.hasInt(data.intCount-1))
					b = false

				// make sure all reals have been synced
				if (data.realCount > 0 and not data.hasReal(data.realCount-1))
					b = false

				// check strings too
				if (data.strCount > 0 and not data.hasString(data.strCount-1))
					b = false

				// and booleans
				if (data.boolCount > 0 and not data.hasBool(data.boolCount-1))
					b = false

				// if everything has been synced
				if (b)

					if (not data.localFinished) // async
						data.localFinished = true

						// notify everyone that the player has recieved all of the data
						SyncInteger(LocalPlayerID, data castTo int)
						
			data = data.next
	
	function startChunk(integer ip, integer endi)
		int i = ip
		integer n = 0
		integer j = 0
		integer p = 0
		string position

		// Begin syncing
		while i <= endi
			print("sync: " + i.toString())
			position = LoadStr(Table, KEY_STR_CACHE, i)
		
			if (i < intCount and LocalPlayer == this.fromP)
				SyncStoredInteger(Cache[0], this.mkey, position)
			if (i < realCount and LocalPlayer == this.fromP)
				SyncStoredReal(Cache[0], this.mkey, position)
			if (i < boolCount and LocalPlayer == this.fromP)
				SyncStoredBoolean(Cache[0], this.mkey, position)
		
			if (i < strCount and LocalPlayer == this.fromP)
				n = LoadInteger(Table, (this castTo int), KEY_STR_LEN + i)
				p = LoadInteger(Table, (this castTo int), KEY_STR_POS + i)
			
				j = 0
			
				while j <= n
				
					position = LoadStr(Table, KEY_STR_CACHE, p + j)

					if (LocalPlayer == this.fromP)
						SyncStoredInteger(Cache[1], this.mkey, position)

					j = j + 1
		
			i = i + 1
		
		if (this.timeStarted != 0.00)
			return
		this.timeStarted = gameTime()
		this.playersDone = 0
		this.buffering   = true
		this.timeElapsed = (UPDATE_PERIOD - TimerGetElapsed(BufferTimer)) * -1
		
		if (Running==0)
			TimerStart(BufferTimer, UPDATE_PERIOD, true, function SyncData.readBuffer)

		Running=Running+1

	function start()
		integer l = intCount

		// Find the highest count
		if (l < realCount)
			l = realCount
		if (l < strCount)
			l = strCount
		if (l < boolCount)
			l = boolCount

		startChunk(0, l)

	function isPlayerDone(player p) returns boolean
		return LoadBoolean(Table, GetPlayerId(p), (this castTo int))

	function isPlayerIdDone(integer pid) returns boolean
		return LoadBoolean(Table, pid, (this castTo int))

	private static function updateStatus() returns boolean
		integer i = 0
		integer p = GetSyncedPlayerId()
		boolean b = true
		boolean c = true
		thistype data = GetSyncedInteger() castTo thistype
		triggercondition tc

		if (not data.buffering)
			return false
		
		data.playersDone = data.playersDone + 1
		SaveBoolean(Table, p, data castTo int, true) // playerdone

		// check if everyone has received the data
		while i < bj_MAX_PLAYER_SLOTS
			p = i
			c = (GetPlayerController(Player(p)) == MAP_CONTROL_USER and GetPlayerSlotState(Player(p)) == PLAYER_SLOT_STATE_PLAYING)
		
			if (c and not data.isPlayerIdDone(p))
				b = false // someone hasn't

			i = i + 1

		// if everyone has recieved the data
		if (b)
			Running = Running-1

			if (Running == 0)
				PauseTimer(BufferTimer)
		
			data.buffering    = false
			data.timeFinished = gameTime()
			data.timeElapsed  = data.timeFinished - data.timeStarted
			
			// fire events
			if (data.onComplete != null)
				data.fireEvent(data.onComplete)

			if (data.eventTrig != null)
				Last = data

				TriggerEvaluate(data.eventTrig)

			FireEvents(EVENT_SYNC_CACHE)

		return false

	private static function trackTime()
		timeCounter = timeCounter + 10
	
	static function onInit()
		Table = InitHashtable()
		Cache[0] = InitGameCache(CACHE_FILE)
		Cache[1] = InitGameCache(CACHE_FILE_STR)
		Elapsed     = CreateTimer()
		BufferTimer = CreateTimer()

		LocalPlayer   = GetLocalPlayer()
		LocalPlayerID = GetPlayerId(LocalPlayer)
		OnSyncInteger(function SyncData.updateStatus)
		TimerStart(Elapsed, 10., true, function SyncData.trackTime)
		
		Initialized = true

init
	SyncData.onInit()
