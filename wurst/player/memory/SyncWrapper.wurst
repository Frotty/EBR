package SyncWrapper
import FileIO
import Table
import initlater PlayerData
import GuardedWorker
import public Network

public constant ALPHABET = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"


class SyncFileTask extends GTask
	PlayerData pd
	string filename
	filterfunc userListener
	SyncedFile file = null

	construct(PlayerData pd, string filename, filterfunc userListener)
		this.pd = pd
		this.userListener = userListener
		this.filename = filename
		
	override function onStart()
		let network = new Network(pd.p)

		if localPlayer == pd.p
			let buffer = network.getData()
			let file = File.open(filename, Mode.READ)
			var e = file.read()
			while e != null
				Log.debug("sync_lines[i]: " + e)
				buffer.writeString(e)
				e = file.read()
			file.close()
		Log.debug("OnLCSync2")

		network.start((Buffer buffer) -> begin
			Log.debug("OnLCSync3")
			Log.debug("OnPFSyncWrapper")
			let task = getCurrentTask() castTo SyncFileTask

			task.file = new SyncedFile()..deserialize(buffer)
			
			Log.debug("OnPFSyncWrapper done")
			getCurrentTask().finish(false)
		end)

	override function onUpdate()

	override function onFinish()
		Log.debug("Sync Task Finished")
		if state == TaskState.TIMEOUT
			Log.error("Sync Task Errored")
		else if state == TaskState.FINISHED
			userListener.evaluate()
			
public function getSyncedFile(PlayerData pd, string filename, filterfunc listener)
	postTask(new SyncFileTask(pd, filename, listener))

trigger trig = CreateTrigger()
function filterfunc.evaluate()
	trig..addCondition(this)
	..evaluate()
	..clearConditions()

interface B
interface A extends B

public function getSyncFileTask() returns SyncFileTask
	let task = getCurrentTask()
	if task instanceof SyncFileTask
		let stask = task castTo SyncFileTask
		return stask
	return null
				
public class SyncedFile implements BufferSerializable
	int size
	int readpos
	Table stringTable = new Table()

	override function serialize(Buffer buffer)

	override function deserialize(Buffer buffer)
		size = 0
		if buffer != null
			var str = buffer.readString()
			Log.debug("buffer.readString(): " + str)
			while str != null and str.length() > 0
				if not ALPHABET.contains(str.substring(str.length()-1, str.length()))
					str = str.substring(0, str.length()-1)
				stringTable.saveString(size, str)
				size++
				str = buffer.readString()
			readpos = size+1
		
	function hasNext() returns boolean
		return readpos > 1
		
	function read() returns string
		readpos--
		return stringTable.loadString(size-readpos)

	ondestroy
		destroy stringTable
		

	
