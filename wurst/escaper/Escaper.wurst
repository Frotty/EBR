package Escaper
	import Entity
	import Vectors
	import Physics
	import Terrain
	import TimerUtils
	import RegionData
	import BuilderConstants
	import ItemObject
	import Key
	import Revivepoint
	import Lists
	
	public Table escaperTable = new Table()
	
	constant real COLL_RADIUS = 32.
	constant real SLIDE_ADD = 1.8
	
	real time = 0.
	
	public LinkedList<Escaper> escapers = new LinkedList<Escaper>()
	
	public class Escaper extends UnitEntity
		int deaths 		= 0
		boolean flying = false
		boolean sliding = false
		boolean onUnwalkable = false
		
		vec3 slideVelocity = vec3(0,0,0)
		vec3 trackVelocity = vec3(0,0,0)
		vec3 vortexVelocity = vec3(0,0,0)
		
		RegionData currentRegion
		real lastAngle = 0.
		
		boolean alive = true

		
		construct( vec3 pos, player owner, int typ )
			super(pos, COLL_RADIUS, CreateUnit(owner, typ, pos.x, pos.y, 0.) )
			actor.addAbility('Aloc')
			.hide()
    		.removeAbility('Aloc')
    		.show()
    		
			TriggerRegisterUnitEvent( slideAssist, actor, EVENT_UNIT_ISSUED_POINT_ORDER )
            TriggerRegisterUnitEvent( slideAssist, actor, EVENT_UNIT_ISSUED_TARGET_ORDER )
            TriggerRegisterUnitEvent( pickupTrig, actor, EVENT_UNIT_PICKUP_ITEM )
            TriggerRegisterUnitEvent( dropTrig, actor, EVENT_UNIT_DROP_ITEM )
			escaperTable.saveInt(GetHandleId(actor), this castTo int)
			currentRegion = regions[0]
			escapers.add(this)

		override function inAir()
			velocity += gravity
			super.inAir()
			if not flying
				flying = true
				SetUnitPropWindow(actor, 0.)
				
				
		override function onGround()
			super.onGround()
			if flying
				flying = false
				SetUnitPropWindow(actor, 60.)
				
			var ttype = GetTerrainType(position.x, position.y)
				
			// pathing
			if not isTerrainWalkable(position.x, position.y)
				velocity = vec3(0.,0.,velocity.z)
			
			if ttype == CONTROLLABLEICE or ttype == UNCONTROLLABLEICE or ttype == REVICE
				let angle = actor.getFacing()
				if angle != lastAngle
					lastAngle = angle
				slideVelocity = vec3(Cos(lastAngle*DEGTORAD) * currentRegion.slidespeed * SLIDE_ADD, Sin(lastAngle*DEGTORAD) * currentRegion.slidespeed * SLIDE_ADD, 0 )
				sliding = true
			else
				slideVelocity *= 0.8
				sliding = false

				
			// ebr (un)walkable
			// print("tile " + currentRegion.unwalkableTile.toString())
			if ttype == currentRegion.unwalkableTile or ttype == 'Ibkb' or ttype == RUNES
				onUnwalkable = true
				kill()
			else
				onUnwalkable = false
				
			velocity*=0.8
				
		function kill()
			if owner.getId() < 8
				getTimer().start(.1, function Escaper.revive).setData(this castTo int)
			else
				getTimer().start(3., function Escaper.revive).setData(this castTo int)
			actor.kill()
			alive = false
		
		override function update()
			terrainZ = getTerrainZ( position.x, position.y )
			position.x = actor.getX()
			position.y = actor.getY()
			if position.z <= terrainZ + 1.
				onGround()
			else
				inAir()

			position += velocity
			
			position += slideVelocity
			position += trackVelocity
			trackVelocity = vec3(0,0,0)
			position += vortexVelocity
			vortexVelocity = vec3(0,0,0)
			time += 0.015625000
			if sliding
				actor.setPos(position.x, position.y)
				
				print(time.toString())
			else
				actor.setXY(position.x, position.y)
            SetUnitFlyHeight( actor, position.z /*- getTerrainZ(position.x, position.y )*/, .0 )
            
		static function revive()
			var t = GetExpiredTimer()
			Escaper e = t.getData() castTo Escaper
			ReviveHero(e.actor, currentRevivepoint.position.x, currentRevivepoint.position.y, false)
			if e.owner.getId() < 8
				if (GetLocalPlayer() == e.owner)
                    PanCameraToTimed(currentRevivepoint.position.x, currentRevivepoint.position.y, 0)
                    ClearSelection()
                    SelectUnit(e.actor, true)
				
			e.alive = true
			t.release()
            
		static function changeAngle()
			var u = GetTriggerUnit()
			Escaper e = u.getUserData() castTo Escaper
			var w = GetOrderTarget()
			unit tu = GetOrderTargetUnit()
            real x2 = GetOrderPointX()
            real y2 = GetOrderPointY()
            real x3 = GetWidgetX(w)
            real y3 = GetWidgetY(w)
            var ttype = GetTerrainType(e.position.x, e.position.y)
            
            if ttype == CONTROLLABLEICE
                if w == null
					e.actor.setFacing(angleBetweenCoordsD(e.position.x,e.position.y,x2,y2))
                else
					e.actor.setFacing(angleBetweenCoordsD(e.position.x,e.position.y,x3,y3))
			else if ttype == REVICE
                if w == null
					e.actor.setFacing(angleBetweenCoordsD(e.position.x,e.position.y,x2,y2)-180)
                else
					e.actor.setFacing(angleBetweenCoordsD(e.position.x,e.position.y,x3,y3)-180)
					
		static function pickupItem()
			var pickedItem = GetManipulatedItem()
			var escaper = GetTriggerUnit().getUserData() castTo Escaper
			var idata = pickedItem.getUserData() castTo ItemObject
			
			if idata instanceof Key
				var kdata = idata castTo Key
				kdata.pickedUp(escaper)
				
		static function dropItem()
			var pickedItem = GetManipulatedItem()
			var escaper = GetTriggerUnit().getUserData() castTo Escaper
			var idata = pickedItem.getUserData() castTo ItemObject
			
			if idata instanceof Key
				var kdata = idata castTo Key
				dropTrig.disable()
				RemoveItem(kdata.actorItem)
				kdata.dropped()
				dropTrig.enable()

			
	trigger slideAssist
	trigger pickupTrig
	public trigger dropTrig
			
	init
		slideAssist = CreateTrigger()
		slideAssist.addAction(function Escaper.changeAngle)
		pickupTrig = CreateTrigger()
		pickupTrig.addAction( function Escaper.pickupItem )
		dropTrig = CreateTrigger()
		dropTrig.addAction( function Escaper.dropItem )
		
endpackage 
