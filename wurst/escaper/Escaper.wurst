package Escaper
	import Entity
	import Vectors
	import Physics
	import Terrain
	import TimerUtils
	import RegionData
	import BuilderConstants
	
	public Table escaperTable = new Table()
	
	constant real COLL_RADIUS = 32.
	constant real SLIDE_ADD = 1.65
	
	public class Escaper extends UnitEntity
		int deaths 		= 0
		boolean flying = false
		boolean sliding = false
		
		vec3 slideVelocity = vec3(0,0,0)
		vec3 trackVelocity = vec3(0,0,0)
		vec3 vortexVelocity = vec3(0,0,0)
		
		RegionData currentRegion
		
		function kill()
			actor.kill()
		
		
		construct( vec3 pos, player owner, int typ )
			super(pos, COLL_RADIUS, CreateUnit(owner, typ, pos.x, pos.y, 0.) )
			TriggerRegisterUnitEvent( slideAssist, actor, EVENT_UNIT_ISSUED_POINT_ORDER )
            TriggerRegisterUnitEvent( slideAssist, actor, EVENT_UNIT_ISSUED_TARGET_ORDER )
			escaperTable.saveInt(GetHandleId(actor), this castTo int)
			currentRegion = regions[0]

		override function inAir()
			velocity += gravity
			super.inAir()
			if not flying
				flying = true
				SetUnitPropWindow(actor, 0.)
				
		override function onGround()
			super.onGround()
			if flying
				flying = false
				SetUnitPropWindow(actor, 60.)
				
			var ttype = GetTerrainType(position.x, position.y)
				
			// pathing
			if not isTerrainWalkable(position.x, position.y)
				velocity = vec3(0.,0.,velocity.z)
			
			if ttype == CONTROLLABLEICE or ttype == UNCONTROLLABLEICE or ttype == REVICE
				let angle = actor.getFacing()
				slideVelocity = vec3(Cos(angle*DEGTORAD) * currentRegion.slidespeed * SLIDE_ADD, Sin(angle*DEGTORAD) * currentRegion.slidespeed * SLIDE_ADD, 0 )
				sliding = true
			else
				slideVelocity *= 0.8
				sliding = false
				
			// ebr (un)walkable
			// print("tile " + currentRegion.unwalkableTile.toString())
			if ttype == currentRegion.unwalkableTile or ttype == 'Ibkb'
				kill()
							
		
		override function update()
			terrainZ = getTerrainZ( position.x, position.y )
			
			if position.z <= terrainZ + 1.
				onGround()
			else
				inAir()
				
			position += velocity
			
			position += slideVelocity
			position += trackVelocity
			trackVelocity = vec3(0,0,0)
			position += vortexVelocity
			vortexVelocity = vec3(0,0,0)
			
			if sliding
				actor.setPos(position.x, position.y)
			else
				actor.setXY(position.x, position.y)
            SetUnitFlyHeight( actor, position.z - getTerrainZ(position.x, position.y ), .0 )
            
		static function changeAngle()
			var u = GetTriggerUnit()
			Escaper e = u.getUserData() castTo Escaper
			var w = GetOrderTarget()
			unit tu = GetOrderTargetUnit()
            real x2 = GetOrderPointX()
            real y2 = GetOrderPointY()
            real x3 = GetWidgetX(w)
            real y3 = GetWidgetY(w)
            var ttype = GetTerrainType(e.position.x, e.position.y)
            
            if ttype == CONTROLLABLEICE or e.flying
                if w == null
					e.actor.setFacing(angleBetweenCoordsD(e.position.x,e.position.y,x2,y2))
                else
					e.actor.setFacing(angleBetweenCoordsD(e.position.x,e.position.y,x3,y3))
			else if ttype == REVICE
                if w == null
					e.actor.setFacing(angleBetweenCoordsD(e.position.x,e.position.y,x2,y2)-180)
                else
					e.actor.setFacing(angleBetweenCoordsD(e.position.x,e.position.y,x3,y3)-180)

			
	trigger slideAssist
			
	init
		slideAssist = CreateTrigger()
		slideAssist.addAction(function Escaper.changeAngle)
		
		
endpackage 
