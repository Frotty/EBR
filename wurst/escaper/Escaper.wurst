package Escaper
import public Json
import StandardTextTags
import PhysicsEntity
import Assets
import public Entity
import public BuilderConstants
import public GameConstants
import RevivePointModifier
import TerrainBlocker
import initlater Weapon
import initlater ReviveManager
import public initlater RegionData
import Projectile
import ErrorHandling
import JukeBox
import public SerializeIds
import initlater PlayerData
import initlater Key

constant real COLL_RADIUS = 32.
constant real SLIDE_ADD = 3.3
constant ANK_ITEM_ID = 'A091'
constant TELEPORT_ITEM_ID = 'A08S'

constant string POISON_EFFECT  = "Abilities\\Weapons\\PoisonSting\\PoisonStingTarget.mdl"
constant string LAVA_EFFECT    = "Abilities\\Spells\\Human\\FlameStrike\\FlameStrikeEmbers.mdl"
public constant JUMP_SPELL = 'A062'
public constant ORB_SPELL = 'A08A'
public constant JAUNT_SPELL = 'A08D'
public constant TOMB_DUMMY_ID = 'u00D'
real time = 0.

public LinkedList<Escaper> escapers = new LinkedList<Escaper>()

public abstract class Escaper extends UnitEntity	
	use PhysicsModule
	RevivePointModifier revmod = null
	boolean onUnwalkable = false
	boolean sliding = false
	boolean poisoned = false
	boolean onLava = false
	boolean camlock = false
	int deaths = 0
	effect lavaEffect
	effect poisonEffect
	vec2 walkVel = vec2(0,0)
	vec2 slideVelocity = vec2(0,0)
	vec2 otherVel = vec2(0,0)
	WeaponObject weapon = null
	effect weaponAttach = null

	boolean alive = true
	boolean selectatrevive = true
	boolean left = false
	unit revivetomb = null
	
	construct( vec3 pos, player owner, int typ )
		super(createUnit(owner, typ, pos + vec3(0,0,32), angle(0)))
		actor..addAbility(LOCUST_ID)..hide()..removeAbility(LOCUST_ID)..show()
		SetUnitPropWindow(actor, 60.)
		EventListener.add(actor, EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER, () -> changeAngle())
		EventListener.add(actor, EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER, () -> changeAngle())
		EventListener.add(actor, EVENT_PLAYER_UNIT_DEATH, () -> kill(null))
		EventListener.add(actor, EVENT_PLAYER_UNIT_PICKUP_ITEM, () -> onPick())
		spellTrig.registerUnitEvent(actor, EVENT_UNIT_SPELL_EFFECT)
		updateRegionData()
		escapers.add(this)
		if this.getCurrentRegion().specialAbil > 0
			actor.addAbility(this.getCurrentRegion().specialAbil)

	function onCPReach()
		if revivetomb != null
			revivetomb.remove()
			revivetomb = null
		actor.setHP(9999)


	function onPick()
		let id = GetManipulatedItem().getTypeId()
		if id == 'I010'
			flashEffect(Other.goldcredit, pos)
			createGoldBountyTextTag(actor, 15, owner)
			owner.addGold(10)
			for pd in escaperPlayers
				pd.p.addGold(5)

	override function inAir(Entity e)
		if not e.flying
			e.flying = true
			onEscapeGround()
		if affectedByGravity
			e.addVel(this.getCurrentRegion().gravity)

	function setLava(boolean add)
		if add and not onLava
			lavaEffect = AddSpecialEffectTarget(LAVA_EFFECT, actor, "origin")
			onLava = true
		else if not add and onLava
			lavaEffect.destr()
			onLava = false
			
	function setPoison(boolean add)
		if add and not poisoned
			poisonEffect = AddSpecialEffectTarget(POISON_EFFECT, actor, "chest")
			poisoned = true
		else if not add and poisoned
			poisonEffect.destr()
			poisoned = false
	
	function kill(UnitEntity killer)
		if this.getCurrentRegion().easyMode and actor.isAlive()
			setPos(pos-getRealVel()*1.05)
			var vel = getRealVel()
			if onUnwalkable
				let norm = vel.norm() * 16
				let tt1un = GetTerrainType(pos.x - norm.x, pos.y) != this.getCurrentRegion().getTypeSet().unwalkableId
				let tt2un = GetTerrainType(pos.x+vel.x, pos.y - norm.y) != this.getCurrentRegion().getTypeSet().unwalkableId
				if tt1un
					vel.x = -vel.x*1.25
				if tt2un
					vel.y = -vel.y*1.25
				setVel(vel)
				if sliding
					actor.setFacing(vel.toVec2().getAngle())
			else
				if killer != null
					let ang = killer.getPos().angleTo2d(pos)
					addVel(vec3(ang.cos()*(10 + vel.length()),ang.sin()*(10+vel.length()),0))
				else
					setVel(getRealVel() * -1.75)
			flashEffect(Other.boltimpact, pos)
			actor.damageTarget(actor, 85)
		else if alive
			alive = false
			actor.kill()
			manageRevive(this)
			setPoison(false)
			setLava(false)
			flying = false
			sliding = false
			deaths++
			
	function stop()
		sliding = false
		slideVelocity = vec2(0,0)
		vel = vec3(0,0,0)
		otherVel = vec2(0,0)

	override function setNewActor(unit u)
		error("Don't do this..")
	
	override function onGroundHit()
		if bitset(tileModifierMap.loadInt((pos.x / 128).round(), (pos.y / 128).round())).contains(TileModifiers.BLUGOO castTo int) and vel.z.abs() > 5
			let rdata = this.getCurrentRegion()
			var ttype = GetTerrainType(pos.x, pos.y)
			// Handle Goo it
			let angl = actor.getFacingAngle()
			if ttype == CONTROLLABLEICE
				vel.x = 0
				vel.y = 0
				slideVelocity = vec2(angl.cos() * rdata.slidespeed * SLIDE_ADD, angl.sin() * rdata.slidespeed * SLIDE_ADD)
			vel.z = -vel.z*1.25
			return
		actor.setPropWindow(60.)
		pos.z = .1
		vel *= 0.175
		vel.z = 0.
		
	override function onEscapeGround()
		actor.setPropWindow(0)
		sliding = false

	int lastVal = -1
	
	override function onGround(Entity e)
		if e.flying
			e.flying = false
			onGroundHit()
		// If the Entity is moving towards
		e.scaleVel(surfaceFriction)
		let rv = getRealVel()
		let lpos = pos.toVec2().polarOffset(rv.toVec2().getAngle()-(90.).asAngleDegrees(), 18)
		let rpos = pos.toVec2().polarOffset(rv.toVec2().getAngle()+(90.).asAngleDegrees(), 18)
		var ttype1 = GetTerrainType(lpos.x, lpos.y)
		var ttype2 = GetTerrainType(rpos.x, rpos.y)
		let rdata = this.getCurrentRegion()
		int ttype
		int newval = -1
		if ttype1 == rdata.getTypeSet().unwalkableId
			if ttype2 == rdata.getTypeSet().unwalkableId
				ttype = rdata.getTypeSet().unwalkableId
			else
				ttype = ttype2
				newval = 2
		else
			if ttype2 == rdata.getTypeSet().unwalkableId
				ttype = ttype1
				newval = 1
			else
				ttype = GetTerrainType(pos.x, pos.y)
				newval = 3
		if((lastVal == 1 and newval == 2) or (lastVal == 2 and newval == 1))
			ttype = rdata.getTypeSet().unwalkableId
		lastVal = newval

		onUnwalkable = false
		slideVelocity *= 0.99
		if ttype == rdata.getTypeSet().unwalkableId or ttype == 'Ibkb' or ttype == RUNES
			if alive
				if rdata.allowCut
					let fpos = pos.toVec2().polarOffset(rv.toVec2().getAngle(), 18)
					let bpos = pos.toVec2().polarOffset(rv.toVec2().getAngle(), -18)
					let t1type = GetTerrainType(fpos.x, fpos.y)
					let t2type = GetTerrainType(bpos.x, bpos.y)
					if (t2type == rdata.getTypeSet().unwalkableId or t2type == 'Ibkb' or t2type == RUNES) and
						(t1type == rdata.getTypeSet().unwalkableId or t1type == 'Ibkb' or t1type == RUNES)
						onUnwalkable = true
						kill(null)
				else
					onUnwalkable = true
					kill(null)
		else if alive and (ttype == CONTROLLABLEICE or ttype == UNCONTROLLABLEICE or ttype == REVICE)
			let angl = actor.getFacingAngle()
			slideVelocity = vec2(angl.cos() * rdata.slidespeed * SLIDE_ADD, angl.sin() * rdata.slidespeed * SLIDE_ADD)
			if not sliding
				speedFactor = 1
				sliding = true
			setLava(false)
		else
			if bitset(tileModifierMap.loadInt((pos.x / 128).round(), (pos.y / 128).round())).contains(TileModifiers.ORANGEGOO castTo int)
				vel += walkVel
				vel *= 1.0075
			vel *= 0.96
			sliding = false
			setLava(false)
			if ttype == 1147958883 and not onLava
				setLava(true)
			else if ttype == POISON
				if not poisoned
					setPoison(true)
		if sliding
			speedFactor *= 0.9
		else
			slideVelocity *= 0.8		
		if onLava
			doLavaDamage()
		if poisoned
			var hp2 = actor.getHP()
			if hp2 > .405
				actor.setHP(hp2-this.getCurrentRegion().poisonDmg)
			else if alive
				kill(null)

	function doLavaDamage()
		var hp = actor.getHP()
		if hp > .405
			actor.setHP(hp-this.getCurrentRegion().lavaDmg)
		else if alive
			kill(null)
		
	override function update()
		let newPos = actor.getPos()
		walkVel = newPos-pos.toVec2()
		pos = newPos.withZ(pos.z)
		physicsUpdate(this)
		pos += vel
		pos += slideVelocity * (1-speedFactor)
		pos += otherVel
		otherVel = vec2(0,0)
		if sliding
			setPos(pos)
		else
			setXY(pos)
		
	override function setXY(vec3 tpos)
		if tpos.inPlayable()
			pos = tpos
			actor.setXYZ(pos)
		else 
			setPos(currentRevivepoint.toVec3())
			kill(null)

	function getRealVel() returns vec3
		return vel + slideVelocity + otherVel + walkVel

	function revive()
		if not alive
			stop()
			let rev = currentRevivepoint
			if revmod == null
				if actor == null
					printLog(Loglevel.ERROR, "why this happening :(")
					super.setNewActor(getUnit(owner, 1, rev, angle(0), this))
				else
					ReviveHero(actor, rev.x, rev.y, false)
				setXY(vec3(rev.x, rev.y, 32.))
			else
				if actor == null
					super.setNewActor(getUnit(owner, 1, revmod.pos, angle(0), this))
				else
					ReviveHero(actor, revmod.pos.x, revmod.pos.y, false)
				setXY(vec3(revmod.pos.x, revmod.pos.y, 32.))
			alive = true
			actor.setPropWindow(60.)
			updateRegionData()
			setPoison(false)
			setLava(false)
			if left
				terminate()
				return

			CameraClearNoiseForPlayer(owner)
			if selectatrevive
				if (GetLocalPlayer() == owner)
					PanCameraToTimed(rev.x, rev.y, 0)
					ClearSelection()
					SelectUnit(actor, true)
			if camlock
				SetCameraTargetControllerNoZForPlayer(owner, actor, 0,0,true)
			if revivetomb != null
				setPos(revivetomb.getPos3Real())
				if selectatrevive
					if (GetLocalPlayer() == owner)
						PanCameraToTimed(pos.x, pos.y, 0)
				revivetomb.remove()
				revivetomb = null
			if this.getCurrentRegion().specialAbil > 0
				actor.addAbility(this.getCurrentRegion().specialAbil)
			else 
				actor.removeAbility(JUMP_SPELL)
				actor.removeAbility(ORB_SPELL)
	
	override function setTarget(vec3 tpos, real speed)
		var t = pos.distanceTo2d(tpos) / speed
		let tangle = pos.angleTo2d(tpos)
		if t < 1.
			t = 1./speed
		
		let startZVelocity = ((-this.getCurrentRegion().gravity.z * t) / 2 - pos.z/t)
		this.setVel( vec3( Cos(tangle.radians()) * speed, Sin(tangle.radians()) * speed, startZVelocity) )
			
	function updateRegionData()
		let currentReg = this.getCurrentRegion()
		let newReg = this.setCurrentRegion()
		if newReg != null and newReg != currentReg
			currentReg.removeEscaper(this)
			newReg.addEscaper(this)
			actor.removeAbility(currentReg.specialAbil)
			if newReg.specialAbil > 0
				actor.addAbility(newReg.specialAbil)
				if isEscaper(actor.getOwner())
					printTimedToPlayer("|cffFFCC00>> |rYou were granted a |cff0884BDspecial ability |rin this region |r(use with hotkey |cffFFCC00T|r)", 10, actor.getOwner())
			else 
				actor.removeAbility(JUMP_SPELL)
				actor.removeAbility(ORB_SPELL)
			actor.setTurnSpeed(newReg.turnSpeed)

	function changeAngle()
		let id = GetIssuedOrderId()
		var w = GetOrderTarget()
		let orderPos = getOrderPos()
		let widgetPos = w.getPos()
		let rv = getRealVel()
		let lpos = pos.toVec2().polarOffset(rv.toVec2().getAngle()-(90.).asAngleDegrees(), 18)
		let rpos = pos.toVec2().polarOffset(rv.toVec2().getAngle()+(90.).asAngleDegrees(), 18)
		var ttype1 = GetTerrainType(lpos.x, lpos.y)
		var ttype2 = GetTerrainType(rpos.x, rpos.y)
		let rdata = this.getCurrentRegion()
		int ttype
		if ttype1 == rdata.getTypeSet().unwalkableId
			if ttype2 == rdata.getTypeSet().unwalkableId
				ttype = rdata.getTypeSet().unwalkableId
			else
				ttype = ttype2
		else
			if ttype2 == rdata.getTypeSet().unwalkableId
				ttype = ttype1
			else
				ttype = GetTerrainType(pos.x, pos.y)
		if ttype == CONTROLLABLEICE
			if w == null
				actor.setFacing(pos.angleTo2d(orderPos))
			else
				actor.setFacing(pos.angleTo2d(widgetPos))
		else if ttype == REVICE
			if OrderId2String(id) == "lightningshield"
				actor.setFacing(pos.angleTo2d(orderPos))
			else
				if w == null
					actor.setFacing(pos.angleTo2d(orderPos)-(180).asAngleDegrees())
				else
					actor.setFacing(pos.angleTo2d(widgetPos)-(180).asAngleDegrees())
				
	static function neutralDeath()
		var escaper = GetTriggerUnit().getUserData() castTo Escaper
		if GetKillingUnit() != null
			escaper.kill(null)
			
	static function onCastEvent()
		let data = GetTriggerUnit().getUserData() castTo Escaper
		data.onCast(GetSpellAbilityId())

	OrbProjectile orb = null
		
	function onCast(int id)
		actor.setAnimation("spell")
		if id == JUMP_SPELL
			if not flying
				addPos(vec3(0,0,1))
				let angl = pos.angleTo2d(getSpellTargetPos())
				addEffect(Other.aneucaster, pos).destr()
				if sliding
					addVel(vec3(3 * angl.cos(), 3 * angl.sin(), 11.5))
				else
					addVel(vec3(7.75 * angl.cos(), 7.75 * angl.sin(), 11.5))
		else if id == ORB_SPELL
			orb = new OrbProjectile(this, getSpellTargetPos())
			orb.addVel((getRealVel()-walkVel)*0.65)
			orb.setXYAngle(orb.vel.toVec2().getAngle())
			actor..removeAbility(ORB_SPELL)..addAbility(JAUNT_SPELL)
		else if id == JAUNT_SPELL
			if orb != null
				setXY(orb.getPos())
				slideVelocity = ZERO2
				setVel(vel * 0.15)
				flashEffect(Other.polymorphtarget, pos)
				orb.terminate()
		else if id == CREATE_REV_MOD_ID
			revmod = new RevivePointModifier(pos.toVec2(), owner)
			UnitRemoveAbility( actor, CREATE_REV_MOD_ID )
			UnitAddAbility( actor, REMOVE_REV_MOD_ID )
		else if id == REMOVE_REV_MOD_ID
			if revmod != null
				destroy revmod
				revmod = null
			UnitRemoveAbility( actor, REMOVE_REV_MOD_ID )
			UnitAddAbility( actor, CREATE_REV_MOD_ID )
		else if id == ATTACK_MELEE or id == ATTACK_RANGED
			weapon.onUse(this)
			actor.setAnimation("attack")
		else if id == ANK_ITEM_ID 
			if poisoned or onLava or sliding or this.getCurrentRegion() == regions[21]
				actor.addItem('I00L')
				createFText(pos, vec2(0,.08), "canceled!", 8.5, 2, colorA(255,0,0,255), owner)
			else
				if revivetomb != null
					revivetomb.remove()
				revivetomb = createUnit(owner, TOMB_DUMMY_ID, pos, angle(0))
		else if id == TELEPORT_ITEM_ID 
			var teleport = true
			for i = 0 to 5
				let ie = UnitItemInSlot(actor, i).getEntity()
				if ie != null and ie instanceof Key
					teleport = false
					break
			if not teleport or poisoned or onLava or sliding or this.getCurrentRegion() == regions[21]
				createFText(pos, vec2(0,.08), "canceled!", 8.5, 2, colorA(255,0,0,255), owner)
			else
				let pos = getSpellTargetPos()
				var smallestDist = 9999999.
				Escaper target = null
				for e in escapers
					if e != this
						let dist = getPos().distanceToSq(e.getPos())
						if dist < smallestDist
							smallestDist = dist
							target = e
				if target == null
					target = this
				flashEffect(Other.blinkcaster, this.getPos())
				setPos(target.getPos())
				flashEffect(Other.blinkcaster, target.getPos())
		else
			jukeBox.checkSpell(id)
			
	ondestroy
		lavaEffect.destr()
		poisonEffect.destr()
		escapers.remove(this)
				
class OrbProjectile extends Projectile
	Escaper e = null
	RegionData rdata

	construct(Escaper e, vec2 target)
		super(e.getPos().moveTowards(target.toVec3(), 16) + vec3(0,0,16), 16, e.owner, e.pos.angleTo2d(target), "TC_EnergyBolt.mdx")
		this.e = e
		this.rdata = this.setCurrentRegion()
		setAcc(0.985)
		setRanged(360)
		setTimed(3)
		setSpeed(9.85)

	ondestroy
		e.orb = null
		e.actor..removeAbility(JAUNT_SPELL)..addAbility(e.getCurrentRegion().specialAbil)
	
	override function update()
		super.update()
		if rdata != this.setCurrentRegion()
			e.kill(null)
			terminate()

public vec2 currentRevivepoint = gg_unit_n000_0002.getPos()
		
trigger neutralDeathTrig
trigger spellTrig

function correctRegion()
	for e from escapers.staticItr()
		e.updateRegionData()
		
@init2 function init_Escaper()
	neutralDeathTrig = CreateTrigger()
	neutralDeathTrig.addAction(function Escaper.neutralDeath)
	getTimer().startPeriodic(1., function correctRegion)
	getTimer().startPeriodic(1., function correctRegion)
	spellTrig = CreateTrigger()
	spellTrig.addAction(function Escaper.onCastEvent)
